{% extends "base.html" %}

{% block title %}Coalition Analysis - Ranked Elections Analyzer{% endblock %}

{% block styles %}
<style>
/* Introduction Panel Styles */
.introduction-panel {
    background: #f0f8f0;
    border: 1px solid #d4edda;
    border-radius: 8px;
    padding: 1.5rem;
    margin-top: 1rem;
    border-left: 4px solid #28a745;
}

.introduction-panel h4 {
    color: #155724;
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.1rem;
}

.introduction-panel h5 {
    color: #155724;
    margin-top: 1.2rem;
    margin-bottom: 0.8rem;
    font-size: 1rem;
}

.introduction-panel p {
    color: #3d5a40;
    line-height: 1.6;
    margin-bottom: 1rem;
}

.introduction-panel ul {
    color: #3d5a40;
    line-height: 1.6;
    margin-left: 1.2rem;
}

.introduction-panel li {
    margin-bottom: 0.5rem;
}

.introduction-panel strong {
    color: #155724;
    font-weight: 600;
}

/* Explanation Panel Styles */
.explanation-panel {
    background: #f8f9ff;
    border: 1px solid #e1e5f0;
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    border-left: 4px solid #3498db;
}

.explanation-panel h4 {
    color: #2c3e50;
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.1rem;
}

.explanation-panel h5 {
    color: #34495e;
    margin-top: 1.5rem;
    margin-bottom: 0.8rem;
    font-size: 1rem;
}

.explanation-panel p {
    color: #5a6c7d;
    line-height: 1.6;
    margin-bottom: 1rem;
}

.explanation-panel ul {
    color: #5a6c7d;
    line-height: 1.6;
    margin-left: 1.2rem;
}

.explanation-panel li {
    margin-bottom: 0.5rem;
}

.explanation-panel strong {
    color: #2c3e50;
    font-weight: 600;
}

.visual-guide, .interaction-guide, .examples-section, .interpretation-guide {
    margin-top: 1.5rem;
}

.examples-section {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 6px;
    padding: 1rem;
    margin-top: 1rem;
}

.interpretation-guide {
    background: #d1ecf1;
    border: 1px solid #bee5eb;
    border-radius: 6px;
    padding: 1rem;
    margin-top: 1rem;
}

.coalition-types-guide {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.type-explanation {
    background: white;
    border: 1px solid #e1e5f0;
    border-radius: 6px;
    padding: 1rem;
}

.type-explanation h5 {
    margin-top: 0;
    margin-bottom: 0.8rem;
    font-size: 0.95rem;
}

.type-explanation p {
    margin-bottom: 0;
    font-size: 0.9rem;
    line-height: 1.5;
}

.definitions-section {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 1rem;
    margin-top: 1rem;
}

.example-calculation {
    background: #e3f2fd;
    border: 1px solid #bbdefb;
    border-radius: 4px;
    padding: 1rem;
    margin-top: 1rem;
    font-size: 0.9rem;
}

.example-calculation h6 {
    margin-top: 0;
    margin-bottom: 0.5rem;
    color: #1565c0;
    font-size: 0.95rem;
}

.example-calculation p {
    margin-bottom: 0.5rem;
    color: #424242;
}

.example-calculation ul {
    margin-bottom: 0;
    color: #424242;
}

.cluster-note {
    background: #fff3e0;
    border: 1px solid #ffcc02;
    border-radius: 4px;
    padding: 0.8rem;
    margin-top: 1rem;
    font-size: 0.9rem;
}

.cluster-note p {
    margin-bottom: 0;
    color: #bf5700;
}

.context-note {
    background: #f0f7ff;
    border: 1px solid #4dabf7;
    border-radius: 4px;
    padding: 0.8rem;
    margin-top: 1rem;
    font-size: 0.9rem;
}

.context-note p {
    margin-bottom: 0;
    color: #1971c2;
}

.table-explanations {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-top: 1rem;
}

.column-explanation, .split-explanation {
    background: white;
    border: 1px solid #e1e5f0;
    border-radius: 6px;
    padding: 1rem;
}

.column-explanation h6, .split-explanation h6 {
    margin-top: 0;
    margin-bottom: 0.8rem;
    color: #2c3e50;
    font-size: 0.95rem;
}

.column-explanation ul, .split-explanation ul {
    margin-bottom: 0;
    font-size: 0.9rem;
}

.column-explanation li, .split-explanation li {
    margin-bottom: 0.4rem;
}

@media (max-width: 768px) {
    .table-explanations {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
}

/* Cluster Visualization Styles */
.cluster-controls {
    background: #f0f4ff;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
    border-left: 4px solid #3498db;
}

.cluster-card {
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.cluster-card.has-winners {
    border-left: 4px solid #e74c3c;
    background: #fff5f5;
}

.cluster-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #eee;
}

.cluster-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: #2c3e50;
}

.cluster-metrics {
    display: flex;
    gap: 1rem;
    align-items: center;
    font-size: 0.9rem;
    color: #7f8c8d;
}

.cluster-candidates {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.candidate-chip {
    background: #ecf0f1;
    padding: 0.3rem 0.8rem;
    border-radius: 20px;
    font-size: 0.85rem;
    color: #2c3e50;
    border: 1px solid #bdc3c7;
}

.candidate-chip.winner {
    background: #e74c3c;
    color: white;
    border-color: #c0392b;
}

/* Network Visualization Styles */
.network-controls {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    min-width: 150px;
}

.control-group label {
    font-size: 0.9rem;
    font-weight: 600;
    color: #2c3e50;
}

.control-group input, .control-group select {
    padding: 0.4rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
}

/* Enhanced Controls Styles */
.enhanced-controls {
    background: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border: 1px solid #e9ecef;
}

.control-row {
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
    flex-wrap: wrap;
    margin-bottom: 1rem;
}

.control-row:last-child {
    margin-bottom: 0;
}

.enhanced-controls .control-group {
    min-width: 200px;
    flex: 1;
}

.enhanced-controls .control-group label {
    font-size: 0.9rem;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 0.3rem;
}

.enhanced-controls .control-group input[type="checkbox"] {
    margin-right: 0.5rem;
    width: auto;
}

.help-text {
    color: #6c757d;
    font-size: 0.8rem;
    margin-top: 0.2rem;
    display: block;
    line-height: 1.3;
}

.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.btn-primary {
    background: #007bff;
    color: white;
}

.btn-primary:hover {
    background: #0056b3;
}

.btn-secondary {
    background: #6c757d;
    color: white;
    margin-left: 0.5rem;
}

.btn-secondary:hover {
    background: #545b62;
}

.methodology-explanation {
    background: #e8f5e8;
    padding: 1rem;
    border-radius: 6px;
    margin-top: 1rem;
    border-left: 4px solid #28a745;
}

.methodology-explanation h4 {
    color: #155724;
    margin-top: 0;
    margin-bottom: 0.5rem;
    font-size: 1rem;
}

.methodology-explanation div {
    color: #3d5a40;
    line-height: 1.5;
}

.network-stats {
    background: #e8f5e8;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    border-left: 4px solid #27ae60;
}

#network-graph {
    width: 100%;
    height: 600px;
    min-height: 600px;
    border: 1px solid #ddd;
    border-radius: 6px;
    position: relative;
    overflow: hidden;
    background: #fafafa;
}

.network-legend {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.95);
    padding: 1rem;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    font-size: 0.9rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.legend-node {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid #333;
}

.legend-node.winner {
    background: #e74c3c;
    border-color: #c0392b;
}

.legend-node.candidate {
    background: #3498db;
    border-color: #2980b9;
}

.legend-edge {
    width: 30px;
    height: 3px;
    border-radius: 2px;
}

.legend-edge.strong {
    background: #27ae60;
}

.legend-edge.moderate {
    background: #f39c12;
}

.legend-edge.weak {
    background: #95a5a6;
}

.legend-edge.strategic {
    background: #9b59b6;
    background-image: repeating-linear-gradient(
        45deg,
        #9b59b6,
        #9b59b6 3px,
        transparent 3px,
        transparent 6px
    );
}

/* Network node and edge styles */
.network-node {
    cursor: pointer;
    stroke: #333;
    stroke-width: 2px;
}

.network-node.winner {
    fill: #e74c3c;
    stroke: #c0392b;
}

.network-node.candidate {
    fill: #3498db;
    stroke: #2980b9;
}

.network-node:hover {
    stroke-width: 3px;
    filter: brightness(1.1);
}

.network-edge {
    stroke-opacity: 0.8;
}

.network-edge.strong {
    stroke: #27ae60;
}

.network-edge.moderate {
    stroke: #f39c12;
}

.network-edge.weak {
    stroke: #95a5a6;
}

.network-edge.strategic {
    stroke: #9b59b6;
    stroke-dasharray: 5,5;
}

.network-label {
    font-size: 12px;
    font-weight: 600;
    fill: #2c3e50;
    text-anchor: middle;
    pointer-events: none;
    text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
}

.network-tooltip {
    position: absolute;
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 0.8rem;
    border-radius: 6px;
    font-size: 0.85rem;
    pointer-events: none;
    z-index: 1000;
    max-width: 300px;
    line-height: 1.4;
}

.btn.secondary {
    background: #95a5a6;
    color: white;
}

.btn.secondary:hover {
    background: #7f8c8d;
}

/* Directional Analysis Styles */
.directional-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.metric-card {
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    transition: box-shadow 0.2s ease;
}

.metric-card:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.metric-card h5 {
    margin: 0 0 0.5rem 0;
    color: #495057;
    font-size: 0.9rem;
}

.metric-value {
    font-size: 2rem;
    font-weight: bold;
    color: #007bff;
    margin: 0.5rem 0;
}

.metric-explanation {
    font-size: 0.8rem;
    color: #6c757d;
    line-height: 1.4;
    margin: 0;
}

.directional-insights {
    background: #f0f8ff;
    border: 1px solid #b8d4f0;
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1.5rem;
}

.directional-insights h5 {
    margin-top: 0;
    color: #2c5aa0;
}

.insight-item {
    background: white;
    border-left: 4px solid #007bff;
    padding: 0.5rem;
    margin: 0.5rem 0;
    border-radius: 0 4px 4px 0;
}

.directional-controls .control-row {
    display: flex;
    gap: 1rem;
    align-items: end;
    flex-wrap: wrap;
}
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h2>🤝 Coalition Analysis Dashboard</h2>
    <p>Explore candidate coalitions, voter preferences, and ranking proximity patterns in the Portland City Council District 2 election.</p>

    <div class="introduction-panel">
        <h4>💡 What You'll Discover Here</h4>
        <p>Coalition analysis reveals the hidden relationships between candidates based on how voters actually ranked them. When voters consistently rank two candidates near each other on their ballots, it suggests these candidates have similar appeal or aligned political positions.</p>

        <div class="key-insights">
            <h5>Key Questions This Analysis Answers:</h5>
            <ul>
                <li><strong>Which candidates worked together effectively?</strong> Identify natural political alliances</li>
                <li><strong>How did winning candidates build coalitions?</strong> See what made the winners successful</li>
                <li><strong>Where do voters see similarities?</strong> Understand voter perception of candidate relationships</li>
                <li><strong>What are the major political groupings?</strong> Discover the election's coalition landscape</li>
            </ul>
        </div>

        <p><strong>💻 Interactive Features:</strong> Use the controls throughout this page to adjust analysis parameters and explore different perspectives on the coalition data. Each visualization offers unique insights into Portland's ranked-choice election dynamics.</p>
    </div>
</div>

<!-- Coalition Type Overview -->
<div class="card">
    <h2>Coalition Type Distribution</h2>
    <p>Overview of different coalition strength levels found in the Portland election data.</p>

    <div class="explanation-panel">
        <h4>Coalition Strength Types Explained</h4>
        <div class="coalition-types-guide">
            <div class="type-explanation">
                <h5>🟢 Strong Coalitions</h5>
                <p>Candidates whose supporters consistently rank them very close together (usually within 1-2 positions). These represent the tightest political alliances.</p>
            </div>
            <div class="type-explanation">
                <h5>🟡 Moderate Coalitions</h5>
                <p>Candidates with meaningful but less intense relationships. Supporters tend to rank them in similar ranges but with more variation.</p>
            </div>
            <div class="type-explanation">
                <h5>⚪ Weak Coalitions</h5>
                <p>Candidates with loose connections. Some voters see similarities, but ranking patterns are inconsistent.</p>
            </div>
            <div class="type-explanation">
                <h5>🟣 Strategic Coalitions</h5>
                <p>Unusual patterns where candidates appear both close and far apart on different ballots, suggesting tactical voting or diverse appeal.</p>
            </div>
        </div>
    </div>

    <div id="coalition-type-loading" class="loading">Loading coalition type breakdown...</div>
    <div id="coalition-type-content" style="display: none;">
        <div id="coalition-type-chart"></div>
        <div id="coalition-type-stats" class="grid"></div>
        <div id="coalition-type-examples"></div>
    </div>
</div>

<!-- Enhanced Statistical Controls -->
<div class="card">
    <h2>📊 Enhanced Statistical Controls</h2>
    <p>Adjust analytical methods to explore different aspects of coalition relationships</p>

    <div class="enhanced-controls">
        <div class="control-row">
            <div class="control-group">
                <label for="analysisMethod">Statistical Method</label>
                <select id="analysisMethod">
                    <option value="proximity_weighted">Proximity Weighted (Default)</option>
                    <option value="basic">Basic Jaccard Similarity</option>
                    <option value="directional">Directional Analysis</option>
                </select>
                <small class="help-text">Choose how coalition strength is calculated</small>
            </div>

            <div class="control-group">
                <label for="normalization">Normalization Method</label>
                <select id="normalization">
                    <option value="raw">Raw Co-occurrence (Default)</option>
                    <option value="conditional">Conditional Probability</option>
                    <option value="lift">Lift (Association Detection)</option>
                </select>
                <small class="help-text">How to normalize for candidate popularity</small>
            </div>

            <div class="control-group">
                <label for="minSharedBallots">Minimum Shared Ballots</label>
                <input type="number" id="minSharedBallots" value="1000" min="50" max="10000" step="100">
                <small class="help-text">Filter out pairs with few shared ballots</small>
            </div>
        </div>

        <div class="control-row">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="ballotLengthFilter">
                    Ballot Length Filtering
                </label>
                <small class="help-text">Control for ballot truncation bias</small>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="confidenceIntervals">
                    Bootstrap Confidence Intervals
                </label>
                <small class="help-text">Add statistical uncertainty estimates</small>
            </div>

            <div class="control-group">
                <button id="applyControls" class="btn btn-primary">Apply Enhanced Analysis</button>
                <button id="resetControls" class="btn btn-secondary">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <div class="methodology-explanation" id="methodologyExplanation">
        <h4>Current Analysis Method</h4>
        <div id="methodExplanation">
            <strong>Proximity Weighted + Raw Normalization:</strong> Standard coalition analysis that weighs ranking closeness heavily. Uses raw co-occurrence without popularity adjustment.
        </div>
    </div>
</div>

<!-- Top Coalition Pairs -->
<div class="card">
    <h2>Strongest Coalition Pairs</h2>
    <p>Candidate pairs ranked by coalition strength (combination of affinity and ranking proximity)</p>

    <div class="explanation-panel">
        <h4>Understanding the Coalition Pairs Table</h4>
        <div class="table-explanations">
            <div class="column-explanation">
                <h6>📊 Column Definitions:</h6>
                <ul>
                    <li><strong>Shared Ballots</strong>: Number of voters who ranked both candidates somewhere on their ballot</li>
                    <li><strong>Avg Distance</strong>: Average ranking positions apart (lower = closer together)</li>
                    <li><strong>Coalition Strength</strong>: Combined score based on how often and how closely candidates are ranked together</li>
                    <li><strong>Close/Distant Ranking Split</strong>: Shows voting pattern consistency</li>
                </ul>
            </div>
            <div class="split-explanation">
                <h6>🔍 Close/Distant Ranking Split Explained:</h6>
                <p>This shows how voters actually ranked these candidates together:</p>
                <ul>
                    <li><strong>Close Rankings (≤2 apart)</strong>: Voters who put both candidates in similar positions (e.g., #1 & #2, or #2 & #4)</li>
                    <li><strong>Distant Rankings (≥4 apart)</strong>: Voters who ranked them far apart (e.g., #1 & #5, or #2 & #6)</li>
                    <li><strong>High close, low distant</strong>: Strong, consistent coalition</li>
                    <li><strong>Mixed close/distant</strong>: More complex voter relationship</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="top-pairs-loading" class="loading">Loading top coalition pairs...</div>
    <div id="top-pairs-content" style="display: none;">
        <table id="top-pairs-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Candidates</th>
                    <th>Coalition Type</th>
                    <th>Shared Ballots</th>
                    <th>Avg Distance</th>
                    <th>Coalition Strength</th>
                    <th>Close/Distant Split</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<!-- Winner Coalition Analysis -->
<div class="card">
    <h2>🏆 Winner Coalition Analysis</h2>
    <p>Analyzing coalition patterns among the three winning candidates: Sameer Kanal, Dan Ryan, and Elana Pirtle-Guiney</p>
    <div id="winner-analysis-loading" class="loading">Loading winner coalition analysis...</div>
    <div id="winner-analysis-content" style="display: none;">
        <div class="grid" id="winner-pairs"></div>
    </div>
</div>

<!-- Directional Analysis: 3 Core Questions Framework -->
<div class="card">
    <h2>🎯 Directional Analysis: 3 Core Questions Framework</h2>
    <p>Deep dive into how votes actually flow between candidates using directional proximity analysis</p>

    <div class="explanation-panel">
        <h4>Understanding Directional Analysis</h4>
        <p>This framework analyzes three fundamental questions about how voters connect two candidates:</p>

        <div class="visual-guide">
            <h5>🔄 The 3 Core Questions:</h5>
            <ul>
                <li><strong>Next Choice Rate (A → B)</strong>: Of ballots that ranked A anywhere, what % had B immediately after A?</li>
                <li><strong>Close-Together Rate (A & B)</strong>: % of ballots that list both A and B within the top 3 spots (in any order)</li>
                <li><strong>Follow-Through (A → B reality)</strong>: When A was eliminated (or had surplus), what share actually landed on B?</li>
            </ul>

            <p><strong>Why This Matters:</strong> Directional analysis reveals asymmetric relationships. For example, A's supporters might consistently rank B next, but B's supporters might prefer other candidates after B.</p>
        </div>
    </div>

    <div class="directional-controls">
        <h4>Select Candidate Pair for Analysis</h4>
        <div class="control-row">
            <div class="control-group">
                <label for="directionalCandidate1">First Candidate</label>
                <select id="directionalCandidate1">
                    <option value="">Select first candidate...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="directionalCandidate2">Second Candidate</label>
                <select id="directionalCandidate2">
                    <option value="">Select second candidate...</option>
                </select>
            </div>
            <div class="control-group">
                <button id="runDirectionalAnalysis" class="btn btn-primary" disabled>Run Directional Analysis</button>
            </div>
        </div>
    </div>

    <div id="directional-loading" class="loading" style="display: none;">Running directional analysis...</div>
    <div id="directional-results" style="display: none;">
        <h4>Directional Analysis Results</h4>
        <div class="directional-metrics">
            <div class="metric-card">
                <h5 id="next-choice-title">Next Choice Rate (A → B)</h5>
                <div class="metric-value" id="next-choice-a-to-b">--</div>
                <p class="metric-explanation" id="next-choice-a-to-b-explanation">--</p>
            </div>
            <div class="metric-card">
                <h5 id="next-choice-reverse-title">Next Choice Rate (B → A)</h5>
                <div class="metric-value" id="next-choice-b-to-a">--</div>
                <p class="metric-explanation" id="next-choice-b-to-a-explanation">--</p>
            </div>
            <div class="metric-card">
                <h5>Close-Together Rate (A & B)</h5>
                <div class="metric-value" id="close-together-rate">--</div>
                <p class="metric-explanation" id="close-together-explanation">--</p>
            </div>
            <div class="metric-card">
                <h5 id="follow-through-title">Follow-Through (A → B reality)</h5>
                <div class="metric-value" id="follow-through-a-to-b">--</div>
                <p class="metric-explanation" id="follow-through-a-to-b-explanation">--</p>
            </div>
            <div class="metric-card">
                <h5 id="follow-through-reverse-title">Follow-Through (B → A reality)</h5>
                <div class="metric-value" id="follow-through-b-to-a">--</div>
                <p class="metric-explanation" id="follow-through-b-to-a-explanation">--</p>
            </div>
        </div>

        <div class="directional-insights">
            <h5>📊 Key Insights</h5>
            <div id="directional-insights-content"></div>
        </div>
    </div>
</div>

<!-- Coalition Clusters -->
<div class="card">
    <h2>🎯 Detected Coalition Groups</h2>
    <p>Automatically detected coalition clusters based on strong relationships between candidates</p>

    <div class="explanation-panel">
        <h4>What are Coalition Groups?</h4>
        <p>Coalition groups are candidates whose supporters tend to rank them similarly on their ballots. When voters consistently rank two candidates close together (like both in their top 3), it suggests these candidates appeal to similar voter bases or have aligned political positions.</p>

        <div class="examples-section">
            <h5>💡 Interactive Tips:</h5>
            <ul>
                <li><strong>Lower "Min Coalition Strength" (0.1-0.15)</strong>: Find more groups, including loose alliances where candidates are sometimes ranked together</li>
                <li><strong>Higher "Min Coalition Strength" (0.3-0.4)</strong>: Only very tight-knit candidate groups where voters consistently ranked them close together</li>
                <li><strong>Smaller "Min Group Size" (2-3)</strong>: See pairs and small alliances</li>
                <li><strong>Larger "Min Group Size" (4-5)</strong>: Only major political coalitions with many connected candidates</li>
            </ul>

            <div class="cluster-note">
                <p><strong>📝 Note:</strong> Groups are formed by connecting candidates who share enough ballots and have sufficient coalition strength, then finding all connected candidates in the network.</p>
            </div>
        </div>

        <div class="interpretation-guide">
            <h5>🔍 How to Read the Results:</h5>
            <ul>
                <li><strong>Groups with 🏆</strong>: Contain winning candidates - successful coalitions</li>
                <li><strong>Group Size</strong>: Number of candidates who voters tend to rank together</li>
                <li><strong>Strength Score</strong>: How consistently voters rank these candidates close together (higher = stronger alliance)</li>
                <li><strong>Red candidate chips</strong>: Winners who formed effective coalitions</li>
            </ul>
        </div>
    </div>

    <div class="cluster-controls">
        <div class="control-group">
            <label for="cluster-strength">Min Coalition Strength:</label>
            <input type="range" id="cluster-strength" min="0.1" max="0.5" step="0.05" value="0.2">
            <span id="cluster-strength-value">0.20</span>
        </div>
        <div class="control-group">
            <label for="cluster-size">Min Group Size:</label>
            <input type="range" id="cluster-size" min="2" max="6" step="1" value="3">
            <span id="cluster-size-value">3</span>
        </div>
        <button class="btn" onclick="updateClusters()">Update Clusters</button>
    </div>

    <div id="clusters-loading" class="loading">Loading coalition clusters...</div>
    <div id="clusters-content" style="display: none;">
        <div id="clusters-summary"></div>
        <div id="clusters-list"></div>
    </div>
</div>

<!-- Coalition Network Visualization -->
<div class="card">
    <h2>🕸️ Interactive Coalition Network</h2>
    <p>Explore candidate relationships as an interactive network graph. Node size represents weighted voter preference (1st choice = 6 points, 2nd = 5 points, etc.), edge thickness represents coalition strength. <strong>Use mouse wheel to zoom, drag to pan, click nodes to highlight connections.</strong></p>

    <div class="explanation-panel">
        <h4>Understanding the Network</h4>
        <p>This network shows how candidates relate to each other based on real voter behavior. Each circle (node) is a candidate, and lines (edges) connect candidates whose supporters ranked them similarly.</p>

        <div class="visual-guide">
            <h5>📊 What the Sizes and Colors Mean:</h5>
            <ul>
                <li><strong>Large circles</strong>: Candidates with high voter preference scores across all ranking positions</li>
                <li><strong>Small circles</strong>: Candidates with fewer high rankings from voters</li>
                <li><strong>Red circles</strong>: The three winning candidates (Elana Pirtle-Guiney, Dan Ryan, Sameer Kanal)</li>
                <li><strong>Blue circles</strong>: All other candidates</li>
                <li><strong>Thick lines</strong>: Strong coalition relationships (voters often ranked these candidates together)</li>
                <li><strong>Thin lines</strong>: Weaker coalition relationships</li>
            </ul>
        </div>

        <div class="interaction-guide">
            <h5>🎮 How to Explore:</h5>
            <ul>
                <li><strong>Click any candidate</strong>: Highlights their coalition network and dims others</li>
                <li><strong>Hover over candidates</strong>: See their weighted preference score and connection count</li>
                <li><strong>Hover over lines</strong>: See detailed coalition information between two candidates</li>
                <li><strong>Zoom in/out</strong>: Mouse wheel to focus on specific areas or see the big picture</li>
                <li><strong>Drag to pan</strong>: Move around the network to explore different regions</li>
            </ul>
        </div>

        <div class="definitions-section">
            <h5>📖 Key Terms:</h5>
            <ul>
                <li><strong>"Shared Ballots"</strong>: Ballots where both candidates appear (are ranked at any position). For example, if 150 voters ranked both Candidate A and Candidate B somewhere on their ballot, that's 150 shared ballots.</li>
                <li><strong>"Coalition Strength"</strong>: How close together candidates were ranked on their shared ballots. Higher values mean voters consistently ranked them near each other (like both in top 3).</li>
                <li><strong>"Min Shared Ballots"</strong>: Only show connections between candidates if at least this many voters ranked both of them.</li>
            </ul>

            <div class="example-calculation">
                <h6>🧮 Example:</h6>
                <p>If you see a line between Candidate A and B with "Coalition Strength: 0.15" and your filter is set to "Min Shared Ballots: 100", this means:</p>
                <ul>
                    <li>At least 100 ballots ranked <strong>both</strong> A and B (anywhere on the ballot)</li>
                    <li>On those shared ballots, A and B were ranked close enough together to create a 0.15 strength score</li>
                    <li>For example: many voters put A as #2 and B as #3, or A as #1 and B as #4, etc.</li>
                </ul>
            </div>
        </div>

        <div class="examples-section">
            <h5>💡 Try These Experiments:</h5>
            <ul>
                <li><strong>Lower "Coalition Strength" to 0.15</strong>: See more connections, including looser alliances</li>
                <li><strong>Raise "Coalition Strength" to 0.4</strong>: Only the very strongest political partnerships</li>
                <li><strong>Lower "Min Shared Ballots" to 100</strong>: Include relationships from smaller voter groups</li>
                <li><strong>Raise "Min Shared Ballots" to 300</strong>: Only show relationships supported by very large numbers of voters</li>
                <li><strong>Filter by "Strong Only"</strong>: Focus on the most significant political alliances</li>
                <li><strong>Click on a winner (red circle)</strong>: See which other candidates formed coalitions with Portland's elected officials</li>
            </ul>

            <div class="context-note">
                <p><strong>📊 Why These Defaults?</strong> In a 20+ candidate race, appearing together on any ballot is meaningful. The default thresholds (200 shared ballots, 0.25 strength) are calibrated to show significant relationships while filtering out statistical noise.</p>
            </div>
        </div>

        <div class="interpretation-guide">
            <h5>🔍 What Patterns to Look For:</h5>
            <ul>
                <li><strong>Clustered groups</strong>: Candidates positioned close together represent political coalitions</li>
                <li><strong>Central vs. peripheral candidates</strong>: Those with many connections vs. those on the edges</li>
                <li><strong>Bridge candidates</strong>: Those connecting different groups, showing broad appeal</li>
                <li><strong>Isolated candidates</strong>: Those with few connections, representing unique political positions</li>
            </ul>
        </div>
    </div>

    <div class="network-controls">
        <div class="control-group">
            <label for="strength-threshold">Coalition Strength Threshold:</label>
            <input type="range" id="strength-threshold" min="0" max="1" step="0.05" value="0.25">
            <span id="strength-value">0.25</span>
        </div>
        <div class="control-group">
            <label for="ballots-threshold">Min Shared Ballots:</label>
            <input type="range" id="ballots-threshold" min="50" max="500" step="25" value="200">
            <span id="ballots-value">200</span>
        </div>
        <div class="control-group">
            <label for="coalition-filter">Coalition Type:</label>
            <select id="coalition-filter">
                <option value="all">All Types</option>
                <option value="strong">Strong Only</option>
                <option value="moderate">Moderate Only</option>
                <option value="weak">Weak Only</option>
                <option value="strategic">Strategic Only</option>
            </select>
        </div>
        <button class="btn" onclick="updateNetwork()">Update Network</button>
        <button class="btn secondary" onclick="resetNetwork()">Reset View</button>
    </div>

    <div id="network-loading" class="loading">Loading coalition network...</div>
    <div id="network-container" style="display: none;">
        <div id="network-stats" class="network-stats"></div>
        <div id="network-graph"></div>
        <div id="network-legend" class="network-legend">
            <h4>Legend</h4>
            <div class="legend-item">
                <div class="legend-node winner"></div>
                <span>Winner</span>
            </div>
            <div class="legend-item">
                <div class="legend-node candidate"></div>
                <span>Other Candidate</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge strong"></div>
                <span>Strong Coalition</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge moderate"></div>
                <span>Moderate Coalition</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge weak"></div>
                <span>Weak Coalition</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge strategic"></div>
                <span>Strategic Coalition</span>
            </div>
        </div>
    </div>
</div>

<!-- Interactive Pair Explorer -->
<div class="card">
    <h2>🔍 Candidate Pair Explorer</h2>
    <p>Select any two candidates to analyze their coalition relationship in detail</p>

    <div class="grid">
        <div class="form-group">
            <label for="candidate1-select">First Candidate:</label>
            <select id="candidate1-select">
                <option value="">Loading candidates...</option>
            </select>
        </div>
        <div class="form-group">
            <label for="candidate2-select">Second Candidate:</label>
            <select id="candidate2-select">
                <option value="">Loading candidates...</option>
            </select>
        </div>
    </div>

    <button class="btn" onclick="analyzePair()">Analyze Pair</button>

    <div id="pair-analysis-result" style="display: none; margin-top: 1rem;">
        <h3>Detailed Pair Analysis</h3>
        <div id="pair-analysis-content"></div>
        <div id="proximity-chart"></div>
    </div>
</div>

<!-- Methodology Explanation -->
<div class="card">
    <h2>📊 Methodology</h2>
    <div class="grid">
        <div>
            <h3>Coalition Types</h3>
            <ul>
                <li><strong>Strong:</strong> Candidates frequently ranked close together (avg distance ≤ 1.5, 60%+ close rankings)</li>
                <li><strong>Moderate:</strong> Candidates often appear together with moderate proximity (avg distance ≤ 2.5, 40%+ close rankings)</li>
                <li><strong>Strategic:</strong> Candidates appear together but with large ranking distances (50%+ distant rankings)</li>
                <li><strong>Weak:</strong> Limited overlap with inconsistent ranking patterns</li>
            </ul>
        </div>
        <div>
            <h3>Key Metrics</h3>
            <ul>
                <li><strong>Avg Distance:</strong> Average ranking positions between candidates</li>
                <li><strong>Coalition Strength:</strong> Combined metric of affinity and proximity</li>
                <li><strong>Close Rankings:</strong> Ballots with candidates ranked ≤ 2 positions apart</li>
                <li><strong>Distant Rankings:</strong> Ballots with candidates ranked ≥ 4 positions apart</li>
            </ul>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Global variables
let candidates = [];
let coalitionPairs = [];

// Initialize the page
document.addEventListener('DOMContentLoaded', async function() {
    await loadCandidates();
    await loadCoalitionTypes();
    await loadTopPairs();
    await loadWinnerAnalysis();
    await loadCoalitionClusters();
    await loadNetworkVisualization();

    // Set up control listeners
    setupNetworkControls();
    setupClusterControls();
    setupEnhancedControls();
    setupDirectionalAnalysis();
});

// Load candidates for dropdowns
async function loadCandidates() {
    try {
        const data = await fetchData('/api/candidates');
        candidates = data; // API returns candidates array directly

        const candidate1Select = document.getElementById('candidate1-select');
        const candidate2Select = document.getElementById('candidate2-select');

        if (!candidate1Select || !candidate2Select) {
            console.error('Candidate select elements not found');
            return;
        }

        candidate1Select.innerHTML = '<option value="">Select first candidate...</option>';
        candidate2Select.innerHTML = '<option value="">Select second candidate...</option>';

        // Also populate directional analysis dropdowns
        const directionalCandidate1 = document.getElementById('directionalCandidate1');
        const directionalCandidate2 = document.getElementById('directionalCandidate2');

        if (directionalCandidate1 && directionalCandidate2) {
            directionalCandidate1.innerHTML = '<option value="">Select first candidate...</option>';
            directionalCandidate2.innerHTML = '<option value="">Select second candidate...</option>';
        }

        candidates.forEach(candidate => {
            const option1 = new Option(candidate.candidate_name, candidate.candidate_id);
            const option2 = new Option(candidate.candidate_name, candidate.candidate_id);
            candidate1Select.add(option1);
            candidate2Select.add(option2);

            // Add to directional analysis dropdowns
            if (directionalCandidate1 && directionalCandidate2) {
                const dirOption1 = new Option(candidate.candidate_name, candidate.candidate_id);
                const dirOption2 = new Option(candidate.candidate_name, candidate.candidate_id);
                directionalCandidate1.add(dirOption1);
                directionalCandidate2.add(dirOption2);
            }
        });

        console.log(`Loaded ${candidates.length} candidates into dropdowns`);
    } catch (error) {
        console.error('Error loading candidates:', error);
        // Show error in dropdowns
        const candidate1Select = document.getElementById('candidate1-select');
        const candidate2Select = document.getElementById('candidate2-select');
        if (candidate1Select) candidate1Select.innerHTML = '<option value="">Error loading candidates</option>';
        if (candidate2Select) candidate2Select.innerHTML = '<option value="">Error loading candidates</option>';
    }
}

// Load coalition type breakdown
async function loadCoalitionTypes() {
    try {
        const data = await fetchData('/api/coalition/types');

        // Create pie chart
        const traces = [{
            type: 'pie',
            labels: Object.keys(data.coalition_type_percentages),
            values: Object.values(data.coalition_type_percentages),
            textinfo: 'label+percent',
            marker: {
                colors: ['#e74c3c', '#f39c12', '#27ae60', '#3498db']
            }
        }];

        const layout = {
            title: 'Coalition Types Distribution',
            height: 400
        };

        Plotly.newPlot('coalition-type-chart', traces, layout);

        // Create stats grid
        const statsHtml = Object.entries(data.coalition_type_counts).map(([type, count]) => `
            <div class="stat-box">
                <span class="stat-number">${count}</span>
                <span class="stat-label">${type.charAt(0).toUpperCase() + type.slice(1)} Coalitions</span>
            </div>
        `).join('');

        document.getElementById('coalition-type-stats').innerHTML = statsHtml;

        // Show examples
        const examplesHtml = Object.entries(data.examples).map(([type, examples]) => `
            <div>
                <h4>${type.charAt(0).toUpperCase() + type.slice(1)} Coalition Examples:</h4>
                <ul>
                    ${examples.map(ex => `
                        <li><strong>${ex.candidate_1_name}</strong> & <strong>${ex.candidate_2_name}</strong>
                        (${ex.shared_ballots.toLocaleString()} ballots, avg distance ${ex.avg_distance})</li>
                    `).join('')}
                </ul>
            </div>
        `).join('');

        document.getElementById('coalition-type-examples').innerHTML = examplesHtml;

        // Show content
        document.getElementById('coalition-type-loading').style.display = 'none';
        document.getElementById('coalition-type-content').style.display = 'block';

    } catch (error) {
        showError('coalition-type-loading', 'Failed to load coalition type data');
    }
}

// Load top coalition pairs with enhanced controls
async function loadTopPairs(params = {}) {
    try {
        const defaultParams = {
            min_shared_ballots: 1000,
            method: 'proximity_weighted',
            normalize: 'raw',
            ballot_length_filter: false,
            confidence_intervals: false
        };

        const queryParams = { ...defaultParams, ...params };
        const urlParams = new URLSearchParams(queryParams);

        const data = await fetchData(`/api/coalition/pairs/all?${urlParams}`);
        coalitionPairs = data.detailed_pairs;

        const tbody = document.querySelector('#top-pairs-table tbody');
        tbody.innerHTML = coalitionPairs.slice(0, 15).map((pair, index) => `
            <tr>
                <td>${index + 1}</td>
                <td><strong>${pair.candidate_1_name}</strong> & <strong>${pair.candidate_2_name}</strong></td>
                <td><span class="coalition-type-${pair.coalition_type}">${pair.coalition_type}</span></td>
                <td>${pair.shared_ballots.toLocaleString()}</td>
                <td>${pair.avg_ranking_distance}</td>
                <td>${pair.coalition_strength_score.toFixed(3)}</td>
                <td>${pair.strong_coalition_votes.toLocaleString()} / ${pair.weak_coalition_votes.toLocaleString()}</td>
                <td>
                    <button class="btn btn-secondary" onclick="quickAnalyzePair(${pair.candidate_1}, ${pair.candidate_2})">
                        Analyze
                    </button>
                </td>
            </tr>
        `).join('');

        document.getElementById('top-pairs-loading').style.display = 'none';
        document.getElementById('top-pairs-content').style.display = 'block';

    } catch (error) {
        showError('top-pairs-loading', 'Failed to load coalition pairs data');
    }
}

// Load winner analysis
async function loadWinnerAnalysis() {
    try {
        // Portland winners: Sameer Kanal (36), Elana Pirtle-Guiney (46), Dan Ryan (55)
        const winners = [
            {id: 36, name: 'Sameer Kanal'},
            {id: 46, name: 'Elana Pirtle-Guiney'},
            {id: 55, name: 'Dan Ryan'}
        ];

        const winnerPairs = [
            [36, 46], // Kanal & Pirtle-Guiney
            [36, 55], // Kanal & Ryan
            [46, 55]  // Pirtle-Guiney & Ryan
        ];

        const pairAnalyses = await Promise.all(
            winnerPairs.map(([id1, id2]) => fetchData(`/api/coalition/pairs/${id1}/${id2}`))
        );

        const winnerPairsHtml = pairAnalyses.map((analysis, index) => {
            const pair = analysis.pair_analysis;
            const proximity = analysis.proximity_analysis;

            return `
                <div class="card">
                    <h3>${pair.candidate_1_name} & ${pair.candidate_2_name}</h3>
                    <div class="grid">
                        <div>
                            <strong>Coalition Type:</strong> ${pair.coalition_type}<br>
                            <strong>Shared Ballots:</strong> ${pair.shared_ballots.toLocaleString()}<br>
                            <strong>Coalition Strength:</strong> ${pair.coalition_strength_score.toFixed(3)}
                        </div>
                        <div>
                            <strong>Avg Distance:</strong> ${pair.avg_ranking_distance}<br>
                            <strong>Close Rankings:</strong> ${proximity.close_rankings.toLocaleString()}<br>
                            <strong>Distant Rankings:</strong> ${proximity.distant_rankings.toLocaleString()}
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="quickAnalyzePair(${pair.candidate_1}, ${pair.candidate_2})">
                        View Details
                    </button>
                </div>
            `;
        }).join('');

        document.getElementById('winner-pairs').innerHTML = winnerPairsHtml;

        document.getElementById('winner-analysis-loading').style.display = 'none';
        document.getElementById('winner-analysis-content').style.display = 'block';

    } catch (error) {
        showError('winner-analysis-loading', 'Failed to load winner analysis data');
    }
}

// Analyze selected pair
async function analyzePair() {
    const candidate1Id = document.getElementById('candidate1-select').value;
    const candidate2Id = document.getElementById('candidate2-select').value;

    if (!candidate1Id || !candidate2Id) {
        alert('Please select both candidates');
        return;
    }

    if (candidate1Id === candidate2Id) {
        alert('Please select two different candidates');
        return;
    }

    await quickAnalyzePair(parseInt(candidate1Id), parseInt(candidate2Id));
}

// Quick analyze pair (used by buttons)
async function quickAnalyzePair(candidate1Id, candidate2Id) {
    try {
        document.getElementById('pair-analysis-result').style.display = 'block';
        document.getElementById('pair-analysis-content').innerHTML = '<div class="loading">Loading detailed analysis...</div>';

        const data = await fetchData(`/api/coalition/pairs/${candidate1Id}/${candidate2Id}`);
        const pair = data.pair_analysis;
        const proximity = data.proximity_analysis;

        // Create detailed analysis content
        const analysisHtml = `
            <div class="grid">
                <div class="card">
                    <h4>Coalition Overview</h4>
                    <p><strong>Type:</strong> ${pair.coalition_type}</p>
                    <p><strong>Shared Ballots:</strong> ${pair.shared_ballots.toLocaleString()}</p>
                    <p><strong>Coalition Strength:</strong> ${pair.coalition_strength_score.toFixed(3)}</p>
                    <p><strong>Basic Affinity:</strong> ${pair.basic_affinity_score.toFixed(3)}</p>
                    ${pair.normalized_affinity_score !== undefined ? `<p><strong>Normalized Affinity:</strong> ${pair.normalized_affinity_score.toFixed(3)}</p>` : ''}
                    <p><strong>Proximity-Weighted Affinity:</strong> ${pair.proximity_weighted_affinity.toFixed(3)}</p>
                </div>
                <div class="card">
                    <h4>Ranking Proximity</h4>
                    <p><strong>Average Distance:</strong> ${proximity.avg_ranking_distance}</p>
                    <p><strong>Median Distance:</strong> ${proximity.median_ranking_distance}</p>
                    <p><strong>Range:</strong> ${proximity.min_distance} - ${proximity.max_distance}</p>
                    <p><strong>Close Rankings (≤2):</strong> ${proximity.close_rankings.toLocaleString()}</p>
                    <p><strong>Distant Rankings (≥4):</strong> ${proximity.distant_rankings.toLocaleString()}</p>
                </div>
                <div class="card">
                    <h4>Vote Transfers</h4>
                    <p><strong>${pair.candidate_1_name} → ${pair.candidate_2_name}:</strong> ${pair.transfer_votes_1_to_2.toLocaleString()}</p>
                    <p><strong>${pair.candidate_2_name} → ${pair.candidate_1_name}:</strong> ${pair.transfer_votes_2_to_1.toLocaleString()}</p>
                    <p><strong>Strong Coalition Votes:</strong> ${pair.strong_coalition_votes.toLocaleString()}</p>
                    <p><strong>Weak Coalition Votes:</strong> ${pair.weak_coalition_votes.toLocaleString()}</p>
                </div>
            </div>
        `;

        document.getElementById('pair-analysis-content').innerHTML = analysisHtml;

        // Create proximity distribution chart
        const distances = Object.keys(proximity.distance_distribution).map(Number);
        const counts = Object.values(proximity.distance_distribution);

        const trace = {
            x: distances,
            y: counts,
            type: 'bar',
            marker: {
                color: distances.map(d => d <= 2 ? '#27ae60' : d >= 4 ? '#e74c3c' : '#f39c12')
            }
        };

        const layout = {
            title: `Ranking Distance Distribution: ${pair.candidate_1_name} & ${pair.candidate_2_name}`,
            xaxis: { title: 'Ranking Distance' },
            yaxis: { title: 'Number of Ballots' },
            height: 400
        };

        Plotly.newPlot('proximity-chart', [trace], layout);

    } catch (error) {
        document.getElementById('pair-analysis-content').innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }
}

// Network Visualization Functions
let networkData = null;
let networkSvg = null;
let simulation = null;

async function loadNetworkVisualization() {
    try {
        document.getElementById('network-loading').style.display = 'block';
        networkData = await fetchData('/api/coalition/network?min_shared_ballots=200&min_strength=0.25');

        console.log('Network data loaded:', {
            nodes: networkData?.nodes?.length,
            edges: networkData?.edges?.length,
            stats: networkData?.stats
        });

        document.getElementById('network-loading').style.display = 'none';
        document.getElementById('network-container').style.display = 'block';

        updateNetworkStats();
        renderNetwork();
    } catch (error) {
        document.getElementById('network-loading').innerHTML = `<div class="error">Error loading network: ${error.message}</div>`;
        console.error('Network loading error:', error);
    }
}

function setupNetworkControls() {
    // Strength threshold slider
    const strengthSlider = document.getElementById('strength-threshold');
    const strengthValue = document.getElementById('strength-value');

    strengthSlider.addEventListener('input', function() {
        strengthValue.textContent = parseFloat(this.value).toFixed(2);
    });

    // Ballots threshold slider
    const ballotsSlider = document.getElementById('ballots-threshold');
    const ballotsValue = document.getElementById('ballots-value');

    ballotsSlider.addEventListener('input', function() {
        ballotsValue.textContent = this.value;
    });
}

async function updateNetwork() {
    const strengthThreshold = parseFloat(document.getElementById('strength-threshold').value);
    const ballotsThreshold = parseInt(document.getElementById('ballots-threshold').value);
    const coalitionFilter = document.getElementById('coalition-filter').value;

    try {
        document.getElementById('network-loading').style.display = 'block';
        document.getElementById('network-container').style.display = 'none';

        networkData = await fetchData(`/api/coalition/network?min_shared_ballots=${ballotsThreshold}&min_strength=${strengthThreshold}`);

        // Apply coalition type filter
        if (coalitionFilter !== 'all') {
            networkData.edges = networkData.edges.filter(edge => edge.coalitionType === coalitionFilter);
        }

        document.getElementById('network-loading').style.display = 'none';
        document.getElementById('network-container').style.display = 'block';

        updateNetworkStats();
        renderNetwork();
    } catch (error) {
        document.getElementById('network-loading').innerHTML = `<div class="error">Error updating network: ${error.message}</div>`;
        console.error('Network update error:', error);
    }
}

function updateNetworkStats() {
    if (!networkData) return;

    const stats = networkData.stats;
    document.getElementById('network-stats').innerHTML = `
        <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
            <div><strong>Candidates:</strong> ${stats.totalNodes}</div>
            <div><strong>Coalition Pairs:</strong> ${stats.totalEdges}</div>
            <div><strong>Avg Strength:</strong> ${stats.avgCoalitionStrength}</div>
            <div><strong>Strong:</strong> ${stats.strongCoalitions}</div>
            <div><strong>Moderate:</strong> ${stats.moderateCoalitions}</div>
            <div><strong>Weak:</strong> ${stats.weakCoalitions}</div>
            <div><strong>Strategic:</strong> ${stats.strategicCoalitions}</div>
        </div>
    `;
}

function renderNetwork() {
    if (!networkData || !networkData.nodes || !networkData.edges) {
        console.error('Invalid network data:', networkData);
        document.getElementById('network-graph').innerHTML = '<div style="padding: 2rem; text-align: center; color: #7f8c8d;">No network data to display</div>';
        return;
    }

    console.log('Rendering network with:', networkData.nodes.length, 'nodes and', networkData.edges.length, 'edges');
    console.log('Sample edge data:', networkData.edges.slice(0, 3));
    console.log('Coalition types in edges:', [...new Set(networkData.edges.map(e => e.coalitionType))]);

    // Debug node vote values and create scaling function
    const voteValues = networkData.nodes.map(n => n.votes).sort((a, b) => b - a);
    const minVotes = Math.min(...voteValues);
    const maxVotes = Math.max(...voteValues);
    const voteRange = maxVotes - minVotes;

    // Create scaling function for node radius based on area (more visually accurate)
    const nodeRadius = (votes) => {
        if (voteRange === 0) return 15;

        // Use square root scaling so area is proportional to votes
        // This makes visual size differences match data differences
        const minArea = Math.PI * 6 * 6; // Min circle area (6px radius)
        const maxArea = Math.PI * 30 * 30; // Max circle area (30px radius)

        const normalized = (votes - minVotes) / voteRange;
        const area = minArea + (normalized * (maxArea - minArea));
        return Math.sqrt(area / Math.PI); // Convert back to radius
    };

    console.log('Vote values range:', {
        min: minVotes,
        max: maxVotes,
        range: voteRange,
        median: voteValues[Math.floor(voteValues.length / 2)],
        sample: voteValues.slice(0, 5)
    });

    // Show top and bottom candidates
    const nodesByVotes = networkData.nodes.sort((a, b) => b.votes - a.votes);
    console.log('Top candidates:', nodesByVotes.slice(0, 3).map(n => ({name: n.name, votes: n.votes, radius: nodeRadius(n.votes)})));
    console.log('Bottom candidates:', nodesByVotes.slice(-3).map(n => ({name: n.name, votes: n.votes, radius: nodeRadius(n.votes)})));

    // Check if we have any edges to display
    if (networkData.edges.length === 0) {
        document.getElementById('network-graph').innerHTML = `
            <div style="padding: 2rem; text-align: center; color: #7f8c8d;">
                <h3>No Coalition Connections Found</h3>
                <p>Try lowering the coalition strength threshold or minimum shared ballots to see more connections.</p>
            </div>
        `;
        return;
    }

    // Clear existing visualization
    document.getElementById('network-graph').innerHTML = '';

    const container = document.getElementById('network-graph');
    const width = container.offsetWidth || 800;
    const height = 600; // Fixed height since CSS might not be reliable

    console.log('Network container dimensions:', { width, height, offsetWidth: container.offsetWidth, offsetHeight: container.offsetHeight });

    // Create SVG with zoom
    const svg = d3.select('#network-graph')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.3, 3])
        .on('zoom', function(event) {
            networkSvg.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Create the main group that will be transformed
    networkSvg = svg.append('g');

    // Create tooltip
    const tooltip = d3.select('#network-graph')
        .append('div')
        .attr('class', 'network-tooltip')
        .style('opacity', 0);

    // Create force simulation
    simulation = d3.forceSimulation(networkData.nodes)
        .force('link', d3.forceLink(networkData.edges).id(d => d.id).distance(d => Math.max(80, 150 - d.strength * 100)))
        .force('charge', d3.forceManyBody().strength(-800))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(d => nodeRadius(d.votes) + 5));

    // Add edges
    const link = networkSvg.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(networkData.edges)
        .enter().append('line')
        .attr('class', d => `network-edge ${d.coalitionType}`)
        .attr('stroke-width', d => Math.max(0.5, d.strength * 4))
        .attr('stroke', d => {
            switch(d.coalitionType) {
                case 'strong': return '#27ae60';
                case 'moderate': return '#f39c12';
                case 'weak': return '#95a5a6';
                case 'strategic': return '#9b59b6';
                default: return '#95a5a6';
            }
        })
        .attr('stroke-opacity', 0.6)
        .attr('stroke-dasharray', d => d.coalitionType === 'strategic' ? '5,5' : null)
        .on('mouseover', function(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${d.source.name} ↔ ${d.target.name}</strong><br/>
                Coalition Type: ${d.coalitionType}<br/>
                Strength: ${d.strength}<br/>
                Shared Ballots: ${d.sharedBallots}<br/>
                Avg Distance: ${d.avgDistance}<br/>
                Strong Votes: ${d.strongVotes}<br/>
                Weak Votes: ${d.weakVotes}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            tooltip.transition().duration(500).style('opacity', 0);
        });

    // Add nodes
    const node = networkSvg.append('g')
        .attr('class', 'nodes')
        .selectAll('circle')
        .data(networkData.nodes)
        .enter().append('circle')
        .attr('class', d => `network-node ${d.group}`)
        .attr('r', d => nodeRadius(d.votes))
        .attr('fill', d => d.isWinner ? '#e74c3c' : '#3498db')
        .attr('stroke', d => d.isWinner ? '#c0392b' : '#2980b9')
        .attr('stroke-width', 2)
        .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended))
        .on('mouseover', function(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${d.name}</strong><br/>
                Weighted Score: ${d.votes.toLocaleString()} points<br/>
                <small>(1st=6pts, 2nd=5pts, 3rd=4pts, etc.)</small><br/>
                Status: ${d.isWinner ? 'Winner' : 'Eliminated'}<br/>
                Coalition Connections: ${networkData.edges.filter(e => e.source.id === d.id || e.target.id === d.id).length}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            tooltip.transition().duration(500).style('opacity', 0);
        })
        .on('click', function(event, d) {
            // Highlight connections
            link.style('opacity', l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1);
            node.style('opacity', n => (n.id === d.id ||
                networkData.edges.some(e => (e.source.id === d.id && e.target.id === n.id) ||
                                           (e.target.id === d.id && e.source.id === n.id))) ? 1 : 0.3);
        });

    // Add labels
    const label = networkSvg.append('g')
        .attr('class', 'labels')
        .selectAll('text')
        .data(networkData.nodes)
        .enter().append('text')
        .attr('class', 'network-label')
        .text(d => d.name.split(' ').slice(-1)[0]) // Show last name only
        .attr('dy', -3);

    // Update positions on simulation tick
    simulation.on('tick', function() {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        label
            .attr('x', d => d.x)
            .attr('y', d => d.y);
    });

    // Drag functions
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
}

function resetNetwork() {
    // Reset all opacities
    if (networkSvg) {
        networkSvg.selectAll('.network-edge').style('opacity', 0.8);
        networkSvg.selectAll('.network-node').style('opacity', 1);
    }

    // Reset controls
    document.getElementById('strength-threshold').value = 0.25;
    document.getElementById('strength-value').textContent = '0.25';
    document.getElementById('ballots-threshold').value = 200;
    document.getElementById('ballots-value').textContent = '200';
    document.getElementById('coalition-filter').value = 'all';

    // Reload network
    loadNetworkVisualization();
}

// Coalition Clustering Functions
async function loadCoalitionClusters() {
    try {
        document.getElementById('clusters-loading').style.display = 'block';
        const clusterData = await fetchData('/api/coalition/clusters?min_strength=0.2&min_group_size=3');

        document.getElementById('clusters-loading').style.display = 'none';
        document.getElementById('clusters-content').style.display = 'block';

        renderClusters(clusterData);
    } catch (error) {
        document.getElementById('clusters-loading').innerHTML = `<div class="error">Error loading clusters: ${error.message}</div>`;
        console.error('Clusters loading error:', error);
    }
}

function setupClusterControls() {
    // Cluster strength slider
    const strengthSlider = document.getElementById('cluster-strength');
    const strengthValue = document.getElementById('cluster-strength-value');

    strengthSlider.addEventListener('input', function() {
        strengthValue.textContent = parseFloat(this.value).toFixed(2);
    });

    // Cluster size slider
    const sizeSlider = document.getElementById('cluster-size');
    const sizeValue = document.getElementById('cluster-size-value');

    sizeSlider.addEventListener('input', function() {
        sizeValue.textContent = this.value;
    });
}

async function updateClusters() {
    const minStrength = parseFloat(document.getElementById('cluster-strength').value);
    const minSize = parseInt(document.getElementById('cluster-size').value);

    try {
        document.getElementById('clusters-loading').style.display = 'block';
        document.getElementById('clusters-content').style.display = 'none';

        const clusterData = await fetchData(`/api/coalition/clusters?min_strength=${minStrength}&min_group_size=${minSize}`);

        document.getElementById('clusters-loading').style.display = 'none';
        document.getElementById('clusters-content').style.display = 'block';

        renderClusters(clusterData);
    } catch (error) {
        document.getElementById('clusters-loading').innerHTML = `<div class="error">Error updating clusters: ${error.message}</div>`;
        console.error('Clusters update error:', error);
    }
}

function renderClusters(clusterData) {
    if (!clusterData || !clusterData.clusters) {
        document.getElementById('clusters-content').innerHTML = '<div class="error">No cluster data available</div>';
        return;
    }

    const summary = clusterData.summary;

    // Render summary
    document.getElementById('clusters-summary').innerHTML = `
        <div style="background: #e8f5e8; padding: 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #27ae60;">
            <strong>Cluster Summary:</strong>
            ${summary.total_clusters} groups found,
            ${summary.total_candidates_clustered} candidates clustered,
            avg size: ${summary.avg_cluster_size},
            largest: ${summary.largest_cluster_size} candidates,
            ${summary.clusters_with_winners} clusters contain winners
        </div>
    `;

    // Render clusters
    if (clusterData.clusters.length === 0) {
        document.getElementById('clusters-list').innerHTML = '<div class="loading">No coalition clusters detected with current parameters. Try lowering the coalition strength threshold.</div>';
        return;
    }

    const clustersHtml = clusterData.clusters.map(cluster => {
        const hasWinners = cluster.has_winners;
        const candidateChips = cluster.candidates.map(candidate => {
            const isWinner = [36, 46, 55].includes(candidate.id);
            return `<span class="candidate-chip ${isWinner ? 'winner' : ''}">${candidate.name}</span>`;
        }).join('');

        return `
            <div class="cluster-card ${hasWinners ? 'has-winners' : ''}">
                <div class="cluster-header">
                    <div class="cluster-title">
                        Coalition Group ${cluster.cluster_id}
                        ${hasWinners ? ' 🏆' : ''}
                    </div>
                    <div class="cluster-metrics">
                        <span><strong>Size:</strong> ${cluster.size}</span>
                        <span><strong>Strength:</strong> ${cluster.internal_strength.toFixed(3)}</span>
                        ${hasWinners ? `<span><strong>Winners:</strong> ${cluster.winners_in_cluster}</span>` : ''}
                    </div>
                </div>
                <div class="cluster-candidates">
                    ${candidateChips}
                </div>
            </div>
        `;
    }).join('');

    document.getElementById('clusters-list').innerHTML = clustersHtml;
}

// Enhanced Controls Functionality
function setupEnhancedControls() {
    const applyButton = document.getElementById('applyControls');
    const resetButton = document.getElementById('resetControls');
    const methodSelect = document.getElementById('analysisMethod');
    const normalizeSelect = document.getElementById('normalization');

    // Update methodology explanation when controls change
    function updateMethodologyExplanation() {
        const method = methodSelect.value;
        const normalize = normalizeSelect.value;
        const ballotFilter = document.getElementById('ballotLengthFilter').checked;
        const confidenceIntervals = document.getElementById('confidenceIntervals').checked;

        let explanation = '';

        // Method explanation
        if (method === 'basic') {
            explanation += '<strong>Basic Jaccard Similarity:</strong> Simple co-occurrence analysis. ';
        } else if (method === 'proximity_weighted') {
            explanation += '<strong>Proximity Weighted:</strong> Emphasizes ranking closeness (default). ';
        } else if (method === 'directional') {
            explanation += '<strong>Directional Analysis:</strong> Tracks A→B vs B→A patterns. ';
        }

        // Normalization explanation
        if (normalize === 'raw') {
            explanation += 'Raw co-occurrence without popularity adjustment.';
        } else if (normalize === 'conditional') {
            explanation += 'Conditional probability: "Of voters who ranked A, what % also ranked B?"';
        } else if (normalize === 'lift') {
            explanation += 'Lift analysis: Detects positive (>1.0) and negative (<1.0) associations.';
        }

        // Additional controls
        if (ballotFilter) {
            explanation += ' <em>Controlling for ballot truncation bias.</em>';
        }
        if (confidenceIntervals) {
            explanation += ' <em>Including bootstrap confidence intervals.</em>';
        }

        document.getElementById('methodExplanation').innerHTML = explanation;
    }

    // Apply enhanced analysis
    async function applyEnhancedAnalysis() {
        const params = {
            min_shared_ballots: parseInt(document.getElementById('minSharedBallots').value),
            method: methodSelect.value,
            normalize: normalizeSelect.value,
            ballot_length_filter: document.getElementById('ballotLengthFilter').checked,
            confidence_intervals: document.getElementById('confidenceIntervals').checked
        };

        // Show loading state
        applyButton.textContent = 'Analyzing...';
        applyButton.disabled = true;

        try {
            // Reload data with new parameters
            await loadTopPairs(params);
            await loadCoalitionTypes(); // Refresh coalition types too

            // Update explanation
            updateMethodologyExplanation();

            // Show success
            applyButton.textContent = 'Applied!';
            setTimeout(() => {
                applyButton.textContent = 'Apply Enhanced Analysis';
                applyButton.disabled = false;
            }, 1500);

        } catch (error) {
            console.error('Enhanced analysis failed:', error);
            applyButton.textContent = 'Error - Try Again';
            applyButton.disabled = false;
        }
    }

    // Reset to defaults
    function resetToDefaults() {
        document.getElementById('analysisMethod').value = 'proximity_weighted';
        document.getElementById('normalization').value = 'raw';
        document.getElementById('minSharedBallots').value = 1000;
        document.getElementById('ballotLengthFilter').checked = false;
        document.getElementById('confidenceIntervals').checked = false;

        updateMethodologyExplanation();
        applyEnhancedAnalysis();
    }

    // Event listeners
    applyButton.addEventListener('click', applyEnhancedAnalysis);
    resetButton.addEventListener('click', resetToDefaults);

    // Update explanation when dropdowns change
    methodSelect.addEventListener('change', updateMethodologyExplanation);
    normalizeSelect.addEventListener('change', updateMethodologyExplanation);
    document.getElementById('ballotLengthFilter').addEventListener('change', updateMethodologyExplanation);
    document.getElementById('confidenceIntervals').addEventListener('change', updateMethodologyExplanation);

    // Initialize explanation
    updateMethodologyExplanation();
}

// Setup directional analysis functionality
function setupDirectionalAnalysis() {
    const directionalCandidate1 = document.getElementById('directionalCandidate1');
    const directionalCandidate2 = document.getElementById('directionalCandidate2');
    const runAnalysisButton = document.getElementById('runDirectionalAnalysis');

    // Enable/disable button based on both candidates being selected
    function updateButtonState() {
        const candidate1Selected = directionalCandidate1.value !== '';
        const candidate2Selected = directionalCandidate2.value !== '';
        const bothSelected = candidate1Selected && candidate2Selected;
        const differentCandidates = directionalCandidate1.value !== directionalCandidate2.value;

        runAnalysisButton.disabled = !bothSelected || !differentCandidates;
    }

    // Run directional analysis
    async function runDirectionalAnalysis() {
        const candidate1Id = directionalCandidate1.value;
        const candidate2Id = directionalCandidate2.value;

        if (!candidate1Id || !candidate2Id || candidate1Id === candidate2Id) {
            alert('Please select two different candidates for analysis.');
            return;
        }

        // Show loading state
        document.getElementById('directional-loading').style.display = 'block';
        document.getElementById('directional-results').style.display = 'none';
        runAnalysisButton.textContent = 'Analyzing...';
        runAnalysisButton.disabled = true;

        try {
            const data = await fetchData(`/api/coalition/directional/${candidate1Id}/${candidate2Id}`);

            // Update the results display
            displayDirectionalResults(data);

            // Show results
            document.getElementById('directional-loading').style.display = 'none';
            document.getElementById('directional-results').style.display = 'block';

        } catch (error) {
            console.error('Directional analysis failed:', error);
            document.getElementById('directional-loading').style.display = 'none';
            alert('Failed to run directional analysis. Please try again.');
        } finally {
            runAnalysisButton.textContent = 'Run Directional Analysis';
            runAnalysisButton.disabled = false;
        }
    }

    // Display directional analysis results
    function displayDirectionalResults(data) {
        const analysis = data.directional_analysis;
        const insights = data.summary_insights;

        // Update metric cards
        document.getElementById('next-choice-title').textContent = analysis.next_choice_rate_a_to_b.question;
        document.getElementById('next-choice-a-to-b').textContent = analysis.next_choice_rate_a_to_b.value + '%';
        document.getElementById('next-choice-a-to-b-explanation').textContent = analysis.next_choice_rate_a_to_b.explanation;

        document.getElementById('next-choice-reverse-title').textContent = analysis.next_choice_rate_b_to_a.question;
        document.getElementById('next-choice-b-to-a').textContent = analysis.next_choice_rate_b_to_a.value + '%';
        document.getElementById('next-choice-b-to-a-explanation').textContent = analysis.next_choice_rate_b_to_a.explanation;

        document.getElementById('close-together-rate').textContent = analysis.close_together_rate.value + '%';
        document.getElementById('close-together-explanation').textContent = analysis.close_together_rate.explanation;

        document.getElementById('follow-through-title').textContent = analysis.follow_through_a_to_b.question;
        document.getElementById('follow-through-a-to-b').textContent = analysis.follow_through_a_to_b.value + '%';
        document.getElementById('follow-through-a-to-b-explanation').textContent = analysis.follow_through_a_to_b.explanation;

        document.getElementById('follow-through-reverse-title').textContent = analysis.follow_through_b_to_a.question;
        document.getElementById('follow-through-b-to-a').textContent = analysis.follow_through_b_to_a.value + '%';
        document.getElementById('follow-through-b-to-a-explanation').textContent = analysis.follow_through_b_to_a.explanation;

        // Generate insights
        let insightsHtml = '';

        if (insights.bidirectional) {
            insightsHtml += '<div class="insight-item">🔄 <strong>Bidirectional Relationship:</strong> Both candidates have similar next-choice rates, suggesting mutual appeal.</div>';
        } else {
            insightsHtml += '<div class="insight-item">➡️ <strong>Asymmetric Relationship:</strong> The candidates have different levels of mutual appeal.</div>';
        }

        if (insights.strong_affinity) {
            insightsHtml += '<div class="insight-item">💪 <strong>Strong Affinity:</strong> High percentage of ballots rank both candidates in their top 3.</div>';
        }

        if (insights.high_follow_through) {
            insightsHtml += '<div class="insight-item">✅ <strong>High Follow-Through:</strong> Theoretical support translates well into actual vote transfers.</div>';
        } else {
            insightsHtml += '<div class="insight-item">⚠️ <strong>Low Follow-Through:</strong> Theoretical support doesn\'t translate well into actual transfers.</div>';
        }

        document.getElementById('directional-insights-content').innerHTML = insightsHtml;
    }

    // Event listeners
    directionalCandidate1.addEventListener('change', updateButtonState);
    directionalCandidate2.addEventListener('change', updateButtonState);
    runAnalysisButton.addEventListener('click', runDirectionalAnalysis);

    // Initialize button state
    updateButtonState();
}
</script>

<style>
.coalition-type-strong {
    background: #27ae60;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85em;
}

.coalition-type-moderate {
    background: #f39c12;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85em;
}

.coalition-type-weak {
    background: #e74c3c;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85em;
}

.coalition-type-strategic {
    background: #9b59b6;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85em;
}

#top-pairs-table th {
    font-size: 0.9em;
}

#top-pairs-table td {
    font-size: 0.85em;
}
</style>
{% endblock %}

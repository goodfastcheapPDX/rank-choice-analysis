{% extends "base.html" %}

{% block title %}Coalition Analysis - Ranked Elections Analyzer{% endblock %}

{% block styles %}
<style>
/* Cluster Visualization Styles */
.cluster-controls {
    background: #f0f4ff;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
    border-left: 4px solid #3498db;
}

.cluster-card {
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.cluster-card.has-winners {
    border-left: 4px solid #e74c3c;
    background: #fff5f5;
}

.cluster-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #eee;
}

.cluster-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: #2c3e50;
}

.cluster-metrics {
    display: flex;
    gap: 1rem;
    align-items: center;
    font-size: 0.9rem;
    color: #7f8c8d;
}

.cluster-candidates {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.candidate-chip {
    background: #ecf0f1;
    padding: 0.3rem 0.8rem;
    border-radius: 20px;
    font-size: 0.85rem;
    color: #2c3e50;
    border: 1px solid #bdc3c7;
}

.candidate-chip.winner {
    background: #e74c3c;
    color: white;
    border-color: #c0392b;
}

/* Network Visualization Styles */
.network-controls {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    min-width: 150px;
}

.control-group label {
    font-size: 0.9rem;
    font-weight: 600;
    color: #2c3e50;
}

.control-group input, .control-group select {
    padding: 0.4rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
}

.network-stats {
    background: #e8f5e8;
    padding: 1rem;
    border-radius: 6px;
    margin-bottom: 1rem;
    border-left: 4px solid #27ae60;
}

#network-graph {
    width: 100%;
    height: 600px;
    min-height: 600px;
    border: 1px solid #ddd;
    border-radius: 6px;
    position: relative;
    overflow: hidden;
    background: #fafafa;
}

.network-legend {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.95);
    padding: 1rem;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    font-size: 0.9rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.legend-node {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid #333;
}

.legend-node.winner {
    background: #e74c3c;
    border-color: #c0392b;
}

.legend-node.candidate {
    background: #3498db;
    border-color: #2980b9;
}

.legend-edge {
    width: 30px;
    height: 3px;
    border-radius: 2px;
}

.legend-edge.strong {
    background: #27ae60;
}

.legend-edge.moderate {
    background: #f39c12;
}

.legend-edge.weak {
    background: #95a5a6;
}

/* Network node and edge styles */
.network-node {
    cursor: pointer;
    stroke: #333;
    stroke-width: 2px;
}

.network-node.winner {
    fill: #e74c3c;
    stroke: #c0392b;
}

.network-node.candidate {
    fill: #3498db;
    stroke: #2980b9;
}

.network-node:hover {
    stroke-width: 3px;
    filter: brightness(1.1);
}

.network-edge {
    stroke-opacity: 0.8;
}

.network-edge.strong {
    stroke: #27ae60;
}

.network-edge.moderate {
    stroke: #f39c12;
}

.network-edge.weak {
    stroke: #95a5a6;
}

.network-edge.strategic {
    stroke: #9b59b6;
    stroke-dasharray: 5,5;
}

.network-label {
    font-size: 12px;
    font-weight: 600;
    fill: #2c3e50;
    text-anchor: middle;
    pointer-events: none;
    text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
}

.network-tooltip {
    position: absolute;
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 0.8rem;
    border-radius: 6px;
    font-size: 0.85rem;
    pointer-events: none;
    z-index: 1000;
    max-width: 300px;
    line-height: 1.4;
}

.btn.secondary {
    background: #95a5a6;
    color: white;
}

.btn.secondary:hover {
    background: #7f8c8d;
}
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h2>ü§ù Coalition Analysis Dashboard</h2>
    <p>Explore candidate coalitions, voter preferences, and ranking proximity patterns in the Portland City Council District 2 election.</p>
</div>

<!-- Coalition Type Overview -->
<div class="card">
    <h2>Coalition Type Distribution</h2>
    <div id="coalition-type-loading" class="loading">Loading coalition type breakdown...</div>
    <div id="coalition-type-content" style="display: none;">
        <div id="coalition-type-chart"></div>
        <div id="coalition-type-stats" class="grid"></div>
        <div id="coalition-type-examples"></div>
    </div>
</div>

<!-- Top Coalition Pairs -->
<div class="card">
    <h2>Strongest Coalition Pairs</h2>
    <p>Candidate pairs ranked by coalition strength (combination of affinity and ranking proximity)</p>
    <div id="top-pairs-loading" class="loading">Loading top coalition pairs...</div>
    <div id="top-pairs-content" style="display: none;">
        <table id="top-pairs-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Candidates</th>
                    <th>Coalition Type</th>
                    <th>Shared Ballots</th>
                    <th>Avg Distance</th>
                    <th>Coalition Strength</th>
                    <th>Strong/Weak Split</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<!-- Winner Coalition Analysis -->
<div class="card">
    <h2>üèÜ Winner Coalition Analysis</h2>
    <p>Analyzing coalition patterns among the three winning candidates: Sameer Kanal, Dan Ryan, and Elana Pirtle-Guiney</p>
    <div id="winner-analysis-loading" class="loading">Loading winner coalition analysis...</div>
    <div id="winner-analysis-content" style="display: none;">
        <div class="grid" id="winner-pairs"></div>
    </div>
</div>

<!-- Coalition Clusters -->
<div class="card">
    <h2>üéØ Detected Coalition Groups</h2>
    <p>Automatically detected coalition clusters based on strong relationships between candidates</p>
    
    <div class="cluster-controls">
        <div class="control-group">
            <label for="cluster-strength">Min Coalition Strength:</label>
            <input type="range" id="cluster-strength" min="0.1" max="0.5" step="0.05" value="0.2">
            <span id="cluster-strength-value">0.20</span>
        </div>
        <div class="control-group">
            <label for="cluster-size">Min Group Size:</label>
            <input type="range" id="cluster-size" min="2" max="6" step="1" value="3">
            <span id="cluster-size-value">3</span>
        </div>
        <button class="btn" onclick="updateClusters()">Update Clusters</button>
    </div>
    
    <div id="clusters-loading" class="loading">Loading coalition clusters...</div>
    <div id="clusters-content" style="display: none;">
        <div id="clusters-summary"></div>
        <div id="clusters-list"></div>
    </div>
</div>

<!-- Coalition Network Visualization -->
<div class="card">
    <h2>üï∏Ô∏è Interactive Coalition Network</h2>
    <p>Explore candidate relationships as an interactive network graph. Node size represents weighted voter preference (1st choice = 6 points, 2nd = 5 points, etc.), edge thickness represents coalition strength. <strong>Use mouse wheel to zoom, drag to pan, click nodes to highlight connections.</strong></p>
    
    <div class="network-controls">
        <div class="control-group">
            <label for="strength-threshold">Coalition Strength Threshold:</label>
            <input type="range" id="strength-threshold" min="0" max="1" step="0.05" value="0.1">
            <span id="strength-value">0.10</span>
        </div>
        <div class="control-group">
            <label for="ballots-threshold">Min Shared Ballots:</label>
            <input type="range" id="ballots-threshold" min="50" max="500" step="25" value="100">
            <span id="ballots-value">100</span>
        </div>
        <div class="control-group">
            <label for="coalition-filter">Coalition Type:</label>
            <select id="coalition-filter">
                <option value="all">All Types</option>
                <option value="strong">Strong Only</option>
                <option value="moderate">Moderate Only</option>
                <option value="weak">Weak Only</option>
                <option value="strategic">Strategic Only</option>
            </select>
        </div>
        <button class="btn" onclick="updateNetwork()">Update Network</button>
        <button class="btn secondary" onclick="resetNetwork()">Reset View</button>
    </div>
    
    <div id="network-loading" class="loading">Loading coalition network...</div>
    <div id="network-container" style="display: none;">
        <div id="network-stats" class="network-stats"></div>
        <div id="network-graph"></div>
        <div id="network-legend" class="network-legend">
            <h4>Legend</h4>
            <div class="legend-item">
                <div class="legend-node winner"></div>
                <span>Winner</span>
            </div>
            <div class="legend-item">
                <div class="legend-node candidate"></div>
                <span>Other Candidate</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge strong"></div>
                <span>Strong Coalition</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge moderate"></div>
                <span>Moderate Coalition</span>
            </div>
            <div class="legend-item">
                <div class="legend-edge weak"></div>
                <span>Weak Coalition</span>
            </div>
        </div>
    </div>
</div>

<!-- Interactive Pair Explorer -->
<div class="card">
    <h2>üîç Candidate Pair Explorer</h2>
    <p>Select any two candidates to analyze their coalition relationship in detail</p>
    
    <div class="grid">
        <div class="form-group">
            <label for="candidate1-select">First Candidate:</label>
            <select id="candidate1-select">
                <option value="">Loading candidates...</option>
            </select>
        </div>
        <div class="form-group">
            <label for="candidate2-select">Second Candidate:</label>
            <select id="candidate2-select">
                <option value="">Loading candidates...</option>
            </select>
        </div>
    </div>
    
    <button class="btn" onclick="analyzePair()">Analyze Pair</button>
    
    <div id="pair-analysis-result" style="display: none; margin-top: 1rem;">
        <h3>Detailed Pair Analysis</h3>
        <div id="pair-analysis-content"></div>
        <div id="proximity-chart"></div>
    </div>
</div>

<!-- Methodology Explanation -->
<div class="card">
    <h2>üìä Methodology</h2>
    <div class="grid">
        <div>
            <h3>Coalition Types</h3>
            <ul>
                <li><strong>Strong:</strong> Candidates frequently ranked close together (avg distance ‚â§ 1.5, 60%+ close rankings)</li>
                <li><strong>Moderate:</strong> Candidates often appear together with moderate proximity (avg distance ‚â§ 2.5, 40%+ close rankings)</li>
                <li><strong>Strategic:</strong> Candidates appear together but with large ranking distances (50%+ distant rankings)</li>
                <li><strong>Weak:</strong> Limited overlap with inconsistent ranking patterns</li>
            </ul>
        </div>
        <div>
            <h3>Key Metrics</h3>
            <ul>
                <li><strong>Avg Distance:</strong> Average ranking positions between candidates</li>
                <li><strong>Coalition Strength:</strong> Combined metric of affinity and proximity</li>
                <li><strong>Close Rankings:</strong> Ballots with candidates ranked ‚â§ 2 positions apart</li>
                <li><strong>Distant Rankings:</strong> Ballots with candidates ranked ‚â• 4 positions apart</li>
            </ul>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Global variables
let candidates = [];
let coalitionPairs = [];

// Initialize the page
document.addEventListener('DOMContentLoaded', async function() {
    await loadCandidates();
    await loadCoalitionTypes();
    await loadTopPairs();
    await loadWinnerAnalysis();
    await loadCoalitionClusters();
    await loadNetworkVisualization();
    
    // Set up control listeners
    setupNetworkControls();
    setupClusterControls();
});

// Load candidates for dropdowns
async function loadCandidates() {
    try {
        const data = await fetchData('/api/candidates');
        candidates = data.candidates;
        
        const candidate1Select = document.getElementById('candidate1-select');
        const candidate2Select = document.getElementById('candidate2-select');
        
        candidate1Select.innerHTML = '<option value="">Select first candidate...</option>';
        candidate2Select.innerHTML = '<option value="">Select second candidate...</option>';
        
        candidates.forEach(candidate => {
            const option1 = new Option(candidate.candidate_name, candidate.candidate_id);
            const option2 = new Option(candidate.candidate_name, candidate.candidate_id);
            candidate1Select.add(option1);
            candidate2Select.add(option2);
        });
    } catch (error) {
        console.error('Error loading candidates:', error);
    }
}

// Load coalition type breakdown
async function loadCoalitionTypes() {
    try {
        const data = await fetchData('/api/coalition/types');
        
        // Create pie chart
        const traces = [{
            type: 'pie',
            labels: Object.keys(data.coalition_type_percentages),
            values: Object.values(data.coalition_type_percentages),
            textinfo: 'label+percent',
            marker: {
                colors: ['#e74c3c', '#f39c12', '#27ae60', '#3498db']
            }
        }];
        
        const layout = {
            title: 'Coalition Types Distribution',
            height: 400
        };
        
        Plotly.newPlot('coalition-type-chart', traces, layout);
        
        // Create stats grid
        const statsHtml = Object.entries(data.coalition_type_counts).map(([type, count]) => `
            <div class="stat-box">
                <span class="stat-number">${count}</span>
                <span class="stat-label">${type.charAt(0).toUpperCase() + type.slice(1)} Coalitions</span>
            </div>
        `).join('');
        
        document.getElementById('coalition-type-stats').innerHTML = statsHtml;
        
        // Show examples
        const examplesHtml = Object.entries(data.examples).map(([type, examples]) => `
            <div>
                <h4>${type.charAt(0).toUpperCase() + type.slice(1)} Coalition Examples:</h4>
                <ul>
                    ${examples.map(ex => `
                        <li><strong>${ex.candidate_1_name}</strong> & <strong>${ex.candidate_2_name}</strong> 
                        (${ex.shared_ballots.toLocaleString()} ballots, avg distance ${ex.avg_distance})</li>
                    `).join('')}
                </ul>
            </div>
        `).join('');
        
        document.getElementById('coalition-type-examples').innerHTML = examplesHtml;
        
        // Show content
        document.getElementById('coalition-type-loading').style.display = 'none';
        document.getElementById('coalition-type-content').style.display = 'block';
        
    } catch (error) {
        showError('coalition-type-loading', 'Failed to load coalition type data');
    }
}

// Load top coalition pairs
async function loadTopPairs() {
    try {
        const data = await fetchData('/api/coalition/pairs/all?min_shared_ballots=1000');
        coalitionPairs = data.detailed_pairs;
        
        const tbody = document.querySelector('#top-pairs-table tbody');
        tbody.innerHTML = coalitionPairs.slice(0, 15).map((pair, index) => `
            <tr>
                <td>${index + 1}</td>
                <td><strong>${pair.candidate_1_name}</strong> & <strong>${pair.candidate_2_name}</strong></td>
                <td><span class="coalition-type-${pair.coalition_type}">${pair.coalition_type}</span></td>
                <td>${pair.shared_ballots.toLocaleString()}</td>
                <td>${pair.avg_ranking_distance}</td>
                <td>${pair.coalition_strength_score.toFixed(3)}</td>
                <td>${pair.strong_coalition_votes.toLocaleString()} / ${pair.weak_coalition_votes.toLocaleString()}</td>
                <td>
                    <button class="btn btn-secondary" onclick="quickAnalyzePair(${pair.candidate_1}, ${pair.candidate_2})">
                        Analyze
                    </button>
                </td>
            </tr>
        `).join('');
        
        document.getElementById('top-pairs-loading').style.display = 'none';
        document.getElementById('top-pairs-content').style.display = 'block';
        
    } catch (error) {
        showError('top-pairs-loading', 'Failed to load coalition pairs data');
    }
}

// Load winner analysis
async function loadWinnerAnalysis() {
    try {
        // Portland winners: Sameer Kanal (36), Elana Pirtle-Guiney (46), Dan Ryan (55)
        const winners = [
            {id: 36, name: 'Sameer Kanal'},
            {id: 46, name: 'Elana Pirtle-Guiney'},
            {id: 55, name: 'Dan Ryan'}
        ];
        
        const winnerPairs = [
            [36, 46], // Kanal & Pirtle-Guiney
            [36, 55], // Kanal & Ryan
            [46, 55]  // Pirtle-Guiney & Ryan
        ];
        
        const pairAnalyses = await Promise.all(
            winnerPairs.map(([id1, id2]) => fetchData(`/api/coalition/pairs/${id1}/${id2}`))
        );
        
        const winnerPairsHtml = pairAnalyses.map((analysis, index) => {
            const pair = analysis.pair_analysis;
            const proximity = analysis.proximity_analysis;
            
            return `
                <div class="card">
                    <h3>${pair.candidate_1_name} & ${pair.candidate_2_name}</h3>
                    <div class="grid">
                        <div>
                            <strong>Coalition Type:</strong> ${pair.coalition_type}<br>
                            <strong>Shared Ballots:</strong> ${pair.shared_ballots.toLocaleString()}<br>
                            <strong>Coalition Strength:</strong> ${pair.coalition_strength_score.toFixed(3)}
                        </div>
                        <div>
                            <strong>Avg Distance:</strong> ${pair.avg_ranking_distance}<br>
                            <strong>Close Rankings:</strong> ${proximity.close_rankings.toLocaleString()}<br>
                            <strong>Distant Rankings:</strong> ${proximity.distant_rankings.toLocaleString()}
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="quickAnalyzePair(${pair.candidate_1}, ${pair.candidate_2})">
                        View Details
                    </button>
                </div>
            `;
        }).join('');
        
        document.getElementById('winner-pairs').innerHTML = winnerPairsHtml;
        
        document.getElementById('winner-analysis-loading').style.display = 'none';
        document.getElementById('winner-analysis-content').style.display = 'block';
        
    } catch (error) {
        showError('winner-analysis-loading', 'Failed to load winner analysis data');
    }
}

// Analyze selected pair
async function analyzePair() {
    const candidate1Id = document.getElementById('candidate1-select').value;
    const candidate2Id = document.getElementById('candidate2-select').value;
    
    if (!candidate1Id || !candidate2Id) {
        alert('Please select both candidates');
        return;
    }
    
    if (candidate1Id === candidate2Id) {
        alert('Please select two different candidates');
        return;
    }
    
    await quickAnalyzePair(parseInt(candidate1Id), parseInt(candidate2Id));
}

// Quick analyze pair (used by buttons)
async function quickAnalyzePair(candidate1Id, candidate2Id) {
    try {
        document.getElementById('pair-analysis-result').style.display = 'block';
        document.getElementById('pair-analysis-content').innerHTML = '<div class="loading">Loading detailed analysis...</div>';
        
        const data = await fetchData(`/api/coalition/pairs/${candidate1Id}/${candidate2Id}`);
        const pair = data.pair_analysis;
        const proximity = data.proximity_analysis;
        
        // Create detailed analysis content
        const analysisHtml = `
            <div class="grid">
                <div class="card">
                    <h4>Coalition Overview</h4>
                    <p><strong>Type:</strong> ${pair.coalition_type}</p>
                    <p><strong>Shared Ballots:</strong> ${pair.shared_ballots.toLocaleString()}</p>
                    <p><strong>Coalition Strength:</strong> ${pair.coalition_strength_score.toFixed(3)}</p>
                    <p><strong>Basic Affinity:</strong> ${pair.basic_affinity_score.toFixed(3)}</p>
                    <p><strong>Proximity-Weighted Affinity:</strong> ${pair.proximity_weighted_affinity.toFixed(3)}</p>
                </div>
                <div class="card">
                    <h4>Ranking Proximity</h4>
                    <p><strong>Average Distance:</strong> ${proximity.avg_ranking_distance}</p>
                    <p><strong>Median Distance:</strong> ${proximity.median_ranking_distance}</p>
                    <p><strong>Range:</strong> ${proximity.min_distance} - ${proximity.max_distance}</p>
                    <p><strong>Close Rankings (‚â§2):</strong> ${proximity.close_rankings.toLocaleString()}</p>
                    <p><strong>Distant Rankings (‚â•4):</strong> ${proximity.distant_rankings.toLocaleString()}</p>
                </div>
                <div class="card">
                    <h4>Vote Transfers</h4>
                    <p><strong>${pair.candidate_1_name} ‚Üí ${pair.candidate_2_name}:</strong> ${pair.transfer_votes_1_to_2.toLocaleString()}</p>
                    <p><strong>${pair.candidate_2_name} ‚Üí ${pair.candidate_1_name}:</strong> ${pair.transfer_votes_2_to_1.toLocaleString()}</p>
                    <p><strong>Strong Coalition Votes:</strong> ${pair.strong_coalition_votes.toLocaleString()}</p>
                    <p><strong>Weak Coalition Votes:</strong> ${pair.weak_coalition_votes.toLocaleString()}</p>
                </div>
            </div>
        `;
        
        document.getElementById('pair-analysis-content').innerHTML = analysisHtml;
        
        // Create proximity distribution chart
        const distances = Object.keys(proximity.distance_distribution).map(Number);
        const counts = Object.values(proximity.distance_distribution);
        
        const trace = {
            x: distances,
            y: counts,
            type: 'bar',
            marker: {
                color: distances.map(d => d <= 2 ? '#27ae60' : d >= 4 ? '#e74c3c' : '#f39c12')
            }
        };
        
        const layout = {
            title: `Ranking Distance Distribution: ${pair.candidate_1_name} & ${pair.candidate_2_name}`,
            xaxis: { title: 'Ranking Distance' },
            yaxis: { title: 'Number of Ballots' },
            height: 400
        };
        
        Plotly.newPlot('proximity-chart', [trace], layout);
        
    } catch (error) {
        document.getElementById('pair-analysis-content').innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }
}

// Network Visualization Functions
let networkData = null;
let networkSvg = null;
let simulation = null;

async function loadNetworkVisualization() {
    try {
        document.getElementById('network-loading').style.display = 'block';
        networkData = await fetchData('/api/coalition/network?min_shared_ballots=100&min_strength=0.1');
        
        console.log('Network data loaded:', {
            nodes: networkData?.nodes?.length,
            edges: networkData?.edges?.length,
            stats: networkData?.stats
        });
        
        document.getElementById('network-loading').style.display = 'none';
        document.getElementById('network-container').style.display = 'block';
        
        updateNetworkStats();
        renderNetwork();
    } catch (error) {
        document.getElementById('network-loading').innerHTML = `<div class="error">Error loading network: ${error.message}</div>`;
        console.error('Network loading error:', error);
    }
}

function setupNetworkControls() {
    // Strength threshold slider
    const strengthSlider = document.getElementById('strength-threshold');
    const strengthValue = document.getElementById('strength-value');
    
    strengthSlider.addEventListener('input', function() {
        strengthValue.textContent = parseFloat(this.value).toFixed(2);
    });
    
    // Ballots threshold slider
    const ballotsSlider = document.getElementById('ballots-threshold');
    const ballotsValue = document.getElementById('ballots-value');
    
    ballotsSlider.addEventListener('input', function() {
        ballotsValue.textContent = this.value;
    });
}

async function updateNetwork() {
    const strengthThreshold = parseFloat(document.getElementById('strength-threshold').value);
    const ballotsThreshold = parseInt(document.getElementById('ballots-threshold').value);
    const coalitionFilter = document.getElementById('coalition-filter').value;
    
    try {
        document.getElementById('network-loading').style.display = 'block';
        document.getElementById('network-container').style.display = 'none';
        
        networkData = await fetchData(`/api/coalition/network?min_shared_ballots=${ballotsThreshold}&min_strength=${strengthThreshold}`);
        
        // Apply coalition type filter
        if (coalitionFilter !== 'all') {
            networkData.edges = networkData.edges.filter(edge => edge.coalitionType === coalitionFilter);
        }
        
        document.getElementById('network-loading').style.display = 'none';
        document.getElementById('network-container').style.display = 'block';
        
        updateNetworkStats();
        renderNetwork();
    } catch (error) {
        document.getElementById('network-loading').innerHTML = `<div class="error">Error updating network: ${error.message}</div>`;
        console.error('Network update error:', error);
    }
}

function updateNetworkStats() {
    if (!networkData) return;
    
    const stats = networkData.stats;
    document.getElementById('network-stats').innerHTML = `
        <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
            <div><strong>Candidates:</strong> ${stats.totalNodes}</div>
            <div><strong>Coalition Pairs:</strong> ${stats.totalEdges}</div>
            <div><strong>Avg Strength:</strong> ${stats.avgCoalitionStrength}</div>
            <div><strong>Strong:</strong> ${stats.strongCoalitions}</div>
            <div><strong>Moderate:</strong> ${stats.moderateCoalitions}</div>
            <div><strong>Weak:</strong> ${stats.weakCoalitions}</div>
            <div><strong>Strategic:</strong> ${stats.strategicCoalitions}</div>
        </div>
    `;
}

function renderNetwork() {
    if (!networkData || !networkData.nodes || !networkData.edges) {
        console.error('Invalid network data:', networkData);
        document.getElementById('network-graph').innerHTML = '<div style="padding: 2rem; text-align: center; color: #7f8c8d;">No network data to display</div>';
        return;
    }
    
    console.log('Rendering network with:', networkData.nodes.length, 'nodes and', networkData.edges.length, 'edges');
    console.log('Sample edge data:', networkData.edges.slice(0, 3));
    console.log('Coalition types in edges:', [...new Set(networkData.edges.map(e => e.coalitionType))]);
    
    // Debug node vote values and create scaling function
    const voteValues = networkData.nodes.map(n => n.votes).sort((a, b) => b - a);
    const minVotes = Math.min(...voteValues);
    const maxVotes = Math.max(...voteValues);
    const voteRange = maxVotes - minVotes;
    
    // Create scaling function for node radius based on area (more visually accurate)
    const nodeRadius = (votes) => {
        if (voteRange === 0) return 15;
        
        // Use square root scaling so area is proportional to votes
        // This makes visual size differences match data differences
        const minArea = Math.PI * 6 * 6; // Min circle area (6px radius)
        const maxArea = Math.PI * 30 * 30; // Max circle area (30px radius)
        
        const normalized = (votes - minVotes) / voteRange;
        const area = minArea + (normalized * (maxArea - minArea));
        return Math.sqrt(area / Math.PI); // Convert back to radius
    };
    
    console.log('Vote values range:', {
        min: minVotes,
        max: maxVotes,
        range: voteRange,
        median: voteValues[Math.floor(voteValues.length / 2)],
        sample: voteValues.slice(0, 5)
    });
    
    // Show top and bottom candidates
    const nodesByVotes = networkData.nodes.sort((a, b) => b.votes - a.votes);
    console.log('Top candidates:', nodesByVotes.slice(0, 3).map(n => ({name: n.name, votes: n.votes, radius: nodeRadius(n.votes)})));
    console.log('Bottom candidates:', nodesByVotes.slice(-3).map(n => ({name: n.name, votes: n.votes, radius: nodeRadius(n.votes)})));
    
    // Check if we have any edges to display
    if (networkData.edges.length === 0) {
        document.getElementById('network-graph').innerHTML = `
            <div style="padding: 2rem; text-align: center; color: #7f8c8d;">
                <h3>No Coalition Connections Found</h3>
                <p>Try lowering the coalition strength threshold or minimum shared ballots to see more connections.</p>
            </div>
        `;
        return;
    }
    
    // Clear existing visualization
    document.getElementById('network-graph').innerHTML = '';
    
    const container = document.getElementById('network-graph');
    const width = container.offsetWidth || 800;
    const height = 600; // Fixed height since CSS might not be reliable
    
    console.log('Network container dimensions:', { width, height, offsetWidth: container.offsetWidth, offsetHeight: container.offsetHeight });
    
    // Create SVG with zoom
    const svg = d3.select('#network-graph')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
    
    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.3, 3])
        .on('zoom', function(event) {
            networkSvg.attr('transform', event.transform);
        });
    
    svg.call(zoom);
    
    // Create the main group that will be transformed
    networkSvg = svg.append('g');
    
    // Create tooltip
    const tooltip = d3.select('#network-graph')
        .append('div')
        .attr('class', 'network-tooltip')
        .style('opacity', 0);
    
    // Create force simulation
    simulation = d3.forceSimulation(networkData.nodes)
        .force('link', d3.forceLink(networkData.edges).id(d => d.id).distance(d => Math.max(80, 150 - d.strength * 100)))
        .force('charge', d3.forceManyBody().strength(-800))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(d => nodeRadius(d.votes) + 5));
    
    // Add edges
    const link = networkSvg.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(networkData.edges)
        .enter().append('line')
        .attr('class', d => `network-edge ${d.coalitionType}`)
        .attr('stroke-width', d => Math.max(0.5, d.strength * 4))
        .attr('stroke', d => {
            switch(d.coalitionType) {
                case 'strong': return '#27ae60';
                case 'moderate': return '#f39c12';
                case 'weak': return '#95a5a6';
                case 'strategic': return '#9b59b6';
                default: return '#95a5a6';
            }
        })
        .attr('stroke-opacity', 0.6)
        .attr('stroke-dasharray', d => d.coalitionType === 'strategic' ? '5,5' : null)
        .on('mouseover', function(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${d.source.name} ‚Üî ${d.target.name}</strong><br/>
                Coalition Type: ${d.coalitionType}<br/>
                Strength: ${d.strength}<br/>
                Shared Ballots: ${d.sharedBallots}<br/>
                Avg Distance: ${d.avgDistance}<br/>
                Strong Votes: ${d.strongVotes}<br/>
                Weak Votes: ${d.weakVotes}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            tooltip.transition().duration(500).style('opacity', 0);
        });
    
    // Add nodes
    const node = networkSvg.append('g')
        .attr('class', 'nodes')
        .selectAll('circle')
        .data(networkData.nodes)
        .enter().append('circle')
        .attr('class', d => `network-node ${d.group}`)
        .attr('r', d => nodeRadius(d.votes))
        .attr('fill', d => d.isWinner ? '#e74c3c' : '#3498db')
        .attr('stroke', d => d.isWinner ? '#c0392b' : '#2980b9')
        .attr('stroke-width', 2)
        .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended))
        .on('mouseover', function(event, d) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(`
                <strong>${d.name}</strong><br/>
                Weighted Score: ${d.votes.toLocaleString()} points<br/>
                <small>(1st=6pts, 2nd=5pts, 3rd=4pts, etc.)</small><br/>
                Status: ${d.isWinner ? 'Winner' : 'Eliminated'}<br/>
                Coalition Connections: ${networkData.edges.filter(e => e.source.id === d.id || e.target.id === d.id).length}
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
            tooltip.transition().duration(500).style('opacity', 0);
        })
        .on('click', function(event, d) {
            // Highlight connections
            link.style('opacity', l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1);
            node.style('opacity', n => (n.id === d.id || 
                networkData.edges.some(e => (e.source.id === d.id && e.target.id === n.id) || 
                                           (e.target.id === d.id && e.source.id === n.id))) ? 1 : 0.3);
        });
    
    // Add labels
    const label = networkSvg.append('g')
        .attr('class', 'labels')
        .selectAll('text')
        .data(networkData.nodes)
        .enter().append('text')
        .attr('class', 'network-label')
        .text(d => d.name.split(' ').slice(-1)[0]) // Show last name only
        .attr('dy', -3);
    
    // Update positions on simulation tick
    simulation.on('tick', function() {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
        
        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);
        
        label
            .attr('x', d => d.x)
            .attr('y', d => d.y);
    });
    
    // Drag functions
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
}

function resetNetwork() {
    // Reset all opacities
    if (networkSvg) {
        networkSvg.selectAll('.network-edge').style('opacity', 0.8);
        networkSvg.selectAll('.network-node').style('opacity', 1);
    }
    
    // Reset controls
    document.getElementById('strength-threshold').value = 0.1;
    document.getElementById('strength-value').textContent = '0.10';
    document.getElementById('ballots-threshold').value = 100;
    document.getElementById('ballots-value').textContent = '100';
    document.getElementById('coalition-filter').value = 'all';
    
    // Reload network
    loadNetworkVisualization();
}

// Coalition Clustering Functions
async function loadCoalitionClusters() {
    try {
        document.getElementById('clusters-loading').style.display = 'block';
        const clusterData = await fetchData('/api/coalition/clusters?min_strength=0.2&min_group_size=3');
        
        document.getElementById('clusters-loading').style.display = 'none';
        document.getElementById('clusters-content').style.display = 'block';
        
        renderClusters(clusterData);
    } catch (error) {
        document.getElementById('clusters-loading').innerHTML = `<div class="error">Error loading clusters: ${error.message}</div>`;
        console.error('Clusters loading error:', error);
    }
}

function setupClusterControls() {
    // Cluster strength slider
    const strengthSlider = document.getElementById('cluster-strength');
    const strengthValue = document.getElementById('cluster-strength-value');
    
    strengthSlider.addEventListener('input', function() {
        strengthValue.textContent = parseFloat(this.value).toFixed(2);
    });
    
    // Cluster size slider
    const sizeSlider = document.getElementById('cluster-size');
    const sizeValue = document.getElementById('cluster-size-value');
    
    sizeSlider.addEventListener('input', function() {
        sizeValue.textContent = this.value;
    });
}

async function updateClusters() {
    const minStrength = parseFloat(document.getElementById('cluster-strength').value);
    const minSize = parseInt(document.getElementById('cluster-size').value);
    
    try {
        document.getElementById('clusters-loading').style.display = 'block';
        document.getElementById('clusters-content').style.display = 'none';
        
        const clusterData = await fetchData(`/api/coalition/clusters?min_strength=${minStrength}&min_group_size=${minSize}`);
        
        document.getElementById('clusters-loading').style.display = 'none';
        document.getElementById('clusters-content').style.display = 'block';
        
        renderClusters(clusterData);
    } catch (error) {
        document.getElementById('clusters-loading').innerHTML = `<div class="error">Error updating clusters: ${error.message}</div>`;
        console.error('Clusters update error:', error);
    }
}

function renderClusters(clusterData) {
    if (!clusterData || !clusterData.clusters) {
        document.getElementById('clusters-content').innerHTML = '<div class="error">No cluster data available</div>';
        return;
    }
    
    const summary = clusterData.summary;
    
    // Render summary
    document.getElementById('clusters-summary').innerHTML = `
        <div style="background: #e8f5e8; padding: 1rem; border-radius: 6px; margin-bottom: 1rem; border-left: 4px solid #27ae60;">
            <strong>Cluster Summary:</strong>
            ${summary.total_clusters} groups found, 
            ${summary.total_candidates_clustered} candidates clustered, 
            avg size: ${summary.avg_cluster_size}, 
            largest: ${summary.largest_cluster_size} candidates,
            ${summary.clusters_with_winners} clusters contain winners
        </div>
    `;
    
    // Render clusters
    if (clusterData.clusters.length === 0) {
        document.getElementById('clusters-list').innerHTML = '<div class="loading">No coalition clusters detected with current parameters. Try lowering the coalition strength threshold.</div>';
        return;
    }
    
    const clustersHtml = clusterData.clusters.map(cluster => {
        const hasWinners = cluster.has_winners;
        const candidateChips = cluster.candidates.map(candidate => {
            const isWinner = [36, 46, 55].includes(candidate.id);
            return `<span class="candidate-chip ${isWinner ? 'winner' : ''}">${candidate.name}</span>`;
        }).join('');
        
        return `
            <div class="cluster-card ${hasWinners ? 'has-winners' : ''}">
                <div class="cluster-header">
                    <div class="cluster-title">
                        Coalition Group ${cluster.cluster_id}
                        ${hasWinners ? ' üèÜ' : ''}
                    </div>
                    <div class="cluster-metrics">
                        <span><strong>Size:</strong> ${cluster.size}</span>
                        <span><strong>Strength:</strong> ${cluster.internal_strength.toFixed(3)}</span>
                        ${hasWinners ? `<span><strong>Winners:</strong> ${cluster.winners_in_cluster}</span>` : ''}
                    </div>
                </div>
                <div class="cluster-candidates">
                    ${candidateChips}
                </div>
            </div>
        `;
    }).join('');
    
    document.getElementById('clusters-list').innerHTML = clustersHtml;
}
</script>

<style>
.coalition-type-strong { 
    background: #27ae60; 
    color: white; 
    padding: 2px 6px; 
    border-radius: 3px; 
    font-size: 0.85em; 
}

.coalition-type-moderate { 
    background: #f39c12; 
    color: white; 
    padding: 2px 6px; 
    border-radius: 3px; 
    font-size: 0.85em; 
}

.coalition-type-weak { 
    background: #e74c3c; 
    color: white; 
    padding: 2px 6px; 
    border-radius: 3px; 
    font-size: 0.85em; 
}

.coalition-type-strategic { 
    background: #9b59b6; 
    color: white; 
    padding: 2px 6px; 
    border-radius: 3px; 
    font-size: 0.85em; 
}

#top-pairs-table th {
    font-size: 0.9em;
}

#top-pairs-table td {
    font-size: 0.85em;
}
</style>
{% endblock %}